// js/ui.js

// Assuming List.js is loaded globally, e.g., via a CDN.
// If you are using ES modules for List.js, you might use:
// import List from 'list.js';
const List = window.List;

// This module handles UI updates and interactions.
// It reads from the state module and updates the DOM via the elements module.
// It does NOT directly manipulate the DOM or call UI rendering functions.

import { elements } from './dom.js'; // Import elements object
import * as state from './state.js'; // UI reads from state
import { getInputElementForContext } from './state.js'; // Import the helper function
import { originalNoteTextBeforeRecording } from './voice.js'; // Import original text holder
import * as config from './config.js'; // Import config for keys
import { escapeHtml, formatFileSize, debounce } from './utils.js'; // Import utility functions, including debounce
import { marked } from 'https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js'; // Import marked for lexer
import { markedRenderer } from './config.js'; // Import the custom renderer from config.js

// Module-level variable to store parsed H1 sections for the current note
let _currentNoteH1Sections = [];

import * as api from './api.js'; // Import API functions

/**
 * Waits for GraphViewer to be available and then processes diagrams.
 * Polls for a limited number of attempts.
 * @param {number} [maxAttempts=30] - Maximum number of times to check (increased to 30).
 * @param {number} [delay=100] - Delay between checks in milliseconds.
 */
function waitForGraphViewerAndProcess(maxAttempts = 30, delay = 100) { // Increased maxAttempts
    let attempts = 0;

    function checkAndProcess() {
        attempts++;
        if (typeof GraphViewer !== 'undefined' && typeof GraphViewer.processElements === 'function') {
            console.log(`[DEBUG] GraphViewer found after ${attempts} attempt(s). Calling processElements().`);
            try {
                GraphViewer.processElements();
            } catch (e) {
                console.error("Error in GraphViewer.processElements():", e);
            }
        } else if (attempts < maxAttempts) {
            // console.log(`[DEBUG] GraphViewer not ready, attempt ${attempts}. Retrying in ${delay}ms...`);
            setTimeout(checkAndProcess, delay);
        } else {
            console.warn(`[WARN] GraphViewer did not become available after ${maxAttempts} attempts.`);
        }
    }

    checkAndProcess(); // Start the check
}


/**
 * Processes an HTML string to make headings collapsible.
 * Wraps headings (h1-h6) and their subsequent content until the next
 * heading of the same or higher level into collapsible sections.
 * @param {string} htmlString - The raw HTML string generated by marked.js.
 * @returns {DocumentFragment} - A DOM fragment with collapsible sections.
 */
function makeHeadingsCollapsible(htmlString) {
    const template = document.createElement('template');
    // Wrap the raw HTML in a single root element to ensure proper parsing of adjacent nodes
    template.innerHTML = `<div>${htmlString.trim()}</div>`;
    const wrapperDiv = template.content.firstChild; // Get the wrapper div

    if (!wrapperDiv) {
        // If htmlString was empty or invalid, return an empty fragment
        return document.createDocumentFragment();
    }

    const nodes = Array.from(wrapperDiv.childNodes);
    const resultFragment = document.createDocumentFragment();
    let currentContentDiv = null; // Keep track of the content div for the current heading

    nodes.forEach(node => {
        const isHeading = node.nodeName && node.nodeName.match(/^H[1-6]$/);

        if (isHeading) {
            // Create the heading element
            const headingElement = node.cloneNode(true); // Clone the original heading
            headingElement.classList.add('collapsible-heading');
            headingElement.style.cursor = 'pointer';
            // Add a unique, deterministic ID for TOC linking
            const level = parseInt(node.nodeName.substring(1), 10);
            const headingText = node.textContent || `heading-${Date.now()}`;
            const slug = headingText.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
            // Use level and slug, remove random part
            const headingId = `toc-heading-level-${level}-${slug}`;
            headingElement.id = headingId;

            const toggleIcon = document.createElement('i');
            toggleIcon.classList.add('fas', 'fa-chevron-down', 'collapsible-toggle', 'mr-2', 'transition-transform', 'duration-200', 'inline-block');
            headingElement.insertBefore(toggleIcon, headingElement.firstChild);

            // Create the content div for this heading
            const contentDiv = document.createElement('div');
            contentDiv.classList.add('collapsible-content'); // Keep this class for collapse functionality
            const sectionId = `collapse-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
            contentDiv.id = sectionId;
            headingElement.dataset.target = `#${sectionId}`; // Link heading to content div

            // Append heading and content div directly to the fragment (flat structure)
            resultFragment.appendChild(headingElement);
            resultFragment.appendChild(contentDiv);

            // Set this new content div as the target for subsequent non-heading nodes
            currentContentDiv = contentDiv;

        } else {
            // Append non-heading nodes
            if (currentContentDiv) {
                // Append to the content div of the most recent heading
                currentContentDiv.appendChild(node.cloneNode(true));
            } else {
                // If before the first heading, append directly to the fragment
                resultFragment.appendChild(node.cloneNode(true));
            }
        }
    });

    return resultFragment;
}


/**
 * Finds all tables within a given container element and initializes List.js for them.
 * Ensures that each table has a proper structure (thead, tbody) and prepares it
 * by adding necessary classes and attributes for List.js.
 * @param {HTMLElement} containerElement - The parent element containing the tables.
 * @param {string} baseId - A base string to create unique IDs for List.js instances.
 */
function initializeListJsForTables(containerElement, baseId) {
    if (!containerElement) {
        console.warn(`[UI.js List.js] initializeListJsForTables called with null containerElement for baseId: ${baseId}`);
        return;
    }
    if (typeof List === 'undefined') {
        console.warn("[UI.js List.js] List.js library is not defined. Skipping table initialization.");
        return;
    }

    const tables = containerElement.querySelectorAll('table');
    if (tables.length === 0) {
        return; // No tables to process
    }

    console.log(`[UI.js List.js] Found ${tables.length} table(s) to process in container for baseId: ${baseId}`);

    tables.forEach((table, tableIndex) => {
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');

        if (!thead || !tbody) {
            console.warn(`[UI.js List.js] Table ${tableIndex} in ${baseId} lacks thead or tbody, skipping List.js initialization.`);
            return;
        }

        // 1. Create a unique ID for the List.js container (wrapper div).
        const listJsContainerId = `${baseId}-table-${tableIndex}-listjs`;

        // 2. Create a new wrapper div for this table.
        // This ensures a clean environment for each List.js instance, especially during re-renders.
        const wrapper = document.createElement('div');
        wrapper.id = listJsContainerId;
        wrapper.classList.add('list-js-initialized-container'); // For styling or identification

        // Replace the table with the wrapper, and move the table into the wrapper.
        if (table.parentNode) {
            table.parentNode.insertBefore(wrapper, table);
        }
        // wrapper.appendChild(table); // table is now a child of wrapper // MOVED: append table after search input

        // Create and add a search input for this table
        const searchInput = document.createElement('input');
        searchInput.type = 'search';
        searchInput.classList.add('list-js-search'); // Use a specific class for styling
        searchInput.placeholder = 'Search this table...';
        // Add the 'search' class that List.js looks for
        searchInput.classList.add('search'); 
        
        wrapper.appendChild(searchInput); // Add search input before the table in the wrapper
        wrapper.appendChild(table); // table is now a child of wrapper, after search input


        // 3. Prepare valueNames from header cells and add sort classes/attributes.
        const headerCells = thead.querySelectorAll('th');
        const valueNames = [];
        headerCells.forEach((th, colIndex) => {
            // Use a simple, predictable valueName based on column index.
            const valueName = `col-${colIndex}`;
            valueNames.push(valueName);

            th.classList.add('sort'); // Class for List.js to identify sortable headers.
            th.dataset.sort = valueName; // Links header to the data via valueName.
            th.style.cursor = 'pointer'; // Visual cue for sortable header.

            // Add corresponding class to each td in this column for all rows in tbody.
            const rows = tbody.querySelectorAll('tr');
            rows.forEach(row => {
                const cell = row.children[colIndex]; // Get td by index.
                if (cell) {
                    // List.js uses these classes on <td>s to find the content for sorting.
                    cell.classList.add(valueName);
                }
            });
        });

        // 4. Add the 'list' class to tbody. List.js uses this to find the item rows (<tr>).
        tbody.classList.add('list');

        // 5. Initialize List.js for this table.
        if (valueNames.length > 0) {
            try {
                // Pass the wrapper DOM element directly instead of its ID
                const listInstance = new List(wrapper, {
                    valueNames: valueNames
                    // item: 'tr' // Optional: explicitly define the item tag name
                });
                console.log(`[UI.js List.js] Initialized for table ${tableIndex} using wrapper element. List.js instance:`, listInstance);
                if (listInstance.items && listInstance.items.length > 0) {
                    console.log(`[UI.js List.js] Found ${listInstance.items.length} items (rows).`);
                    // Log values of the first item for inspection
                    console.log(`[UI.js List.js] Values for first item:`, listInstance.items[0].values());
                    if (listInstance.items.length > 1) {
                         console.log(`[UI.js List.js] Values for second item (if exists):`, listInstance.items[1].values());
                    }
                } else {
                    console.warn(`[UI.js List.js] List.js initialized but found 0 items in ${listJsContainerId}. Check .list class on tbody and item structure.`);
                }
            } catch (e) {
                console.error(`[UI.js List.js] Error initializing for table ${tableIndex} in ${listJsContainerId}:`, e);
            }
        } else {
            console.warn(`[UI.js List.js] No valueNames generated for table ${tableIndex} in ${listJsContainerId}. List.js not initialized.`);
        }
    });
}


// --- Render Functions (Read State, Update DOM) ---

/**
 * Renders the current status message in the status bar.
 */
export function renderStatus() {
    if (elements.statusBar) {
        elements.statusBar.textContent = `Status: ${state.statusMessage}`;
        if (state.isErrorStatus) {
            elements.statusBar.classList.add('text-red-500');
            elements.statusBar.classList.remove('text-gray-700'); // Assuming a default non-error color
        } else {
            elements.statusBar.classList.remove('text-red-500');
            elements.statusBar.classList.add('text-gray-700'); // Assuming a default non-error color
        }
    } else {
        console.warn("Status bar element not found for status update.");
    }
}

/**
 * Updates the loading state of UI elements.
 * Disables global actions based on `state.isLoading`.
 * Disables chat-specific inputs based on `state.processingChatId`.
 */
export function updateLoadingState() {
    const isGloballyLoading = state.isLoading; // For non-chat operations
    const isCurrentChatProcessing = state.currentChatId !== null && state.currentChatId === state.processingChatId;

    // --- Disable/Modify Chat-Specific Inputs if *Current Chat* is Processing ---
    if (elements.messageInput) elements.messageInput.disabled = isCurrentChatProcessing;
    if (elements.sendButton) {
        const sendButtonIcon = elements.sendButton.querySelector('i'); // Find the icon
        // Find the text node within the button (assuming it's directly after the icon or the last text node)
        let buttonTextNode = null;
        for (const node of elements.sendButton.childNodes) {
            // Find the last text node that isn't just whitespace
            if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim()) {
                buttonTextNode = node;
            }
        }
        // Fallback: If no text node found, maybe create one? For now, log error if needed.
        if (!buttonTextNode) {
            // console.warn("Could not find text node within send button to update.");
        }

        if (isCurrentChatProcessing) {
            // Change to Stop button
            elements.sendButton.disabled = false; // Keep button enabled to allow stopping
            elements.sendButton.title = "Stop Generation";
            elements.sendButton.classList.add('stop-button'); // Add class for styling
            if (sendButtonIcon) {
                sendButtonIcon.classList.remove('fa-paper-plane');
                sendButtonIcon.classList.add('fa-stop');
            }
            if (buttonTextNode) {
                buttonTextNode.nodeValue = ' Stop'; // Update text content (add space for padding)
            }
        } else {
            // Change back to Send button
            elements.sendButton.disabled = isGloballyLoading; // Disable only if globally loading, not just processing
            elements.sendButton.title = "Send Message";
            elements.sendButton.classList.remove('stop-button'); // Remove class
            if (sendButtonIcon) {
                sendButtonIcon.classList.remove('fa-stop');
                sendButtonIcon.classList.add('fa-paper-plane');
            }
            if (buttonTextNode) {
                buttonTextNode.nodeValue = ' Send'; // Restore original text content (add space for padding)
            }
        }
    }
    if (elements.modelSelector) elements.modelSelector.disabled = isCurrentChatProcessing || isGloballyLoading; // Disable if processing OR globally loading
    if (elements.micButton) elements.micButton.disabled = isCurrentChatProcessing || isGloballyLoading;
    if (elements.cleanupTranscriptButton) elements.cleanupTranscriptButton.disabled = isCurrentChatProcessing || isGloballyLoading;
    if (elements.fileUploadSessionLabel) elements.fileUploadSessionLabel.classList.toggle('disabled', isCurrentChatProcessing || isGloballyLoading);
 
    if (elements.newChatButton) elements.newChatButton.disabled = isGloballyLoading;
    if (elements.saveChatNameButton) elements.saveChatNameButton.disabled = isGloballyLoading;
    if (elements.currentChatNameInput) elements.currentChatNameInput.disabled = isGloballyLoading;
    if (elements.newNoteButton) elements.newNoteButton.disabled = isGloballyLoading;
    if (elements.saveNoteNameButton) elements.saveNoteNameButton.disabled = isGloballyLoading;
    if (elements.currentNoteNameInput) elements.currentNoteNameInput.disabled = isGloballyLoading;
    if (elements.loadCalendarButton) elements.loadCalendarButton.disabled = isGloballyLoading;
    if (elements.manageFilesButton) elements.manageFilesButton.disabled = isGloballyLoading;
    if (elements.fetchUrlButton) elements.fetchUrlButton.disabled = isGloballyLoading;
    if (elements.saveSummaryButton) elements.saveSummaryButton.disabled = isGloballyLoading;
    if (elements.settingsButton) elements.settingsButton.disabled = isGloballyLoading;
    if (elements.fileUploadModalInput) elements.fileUploadModalInput.disabled = isGloballyLoading;
    if (elements.fileUploadModalLabel) elements.fileUploadModalLabel.classList.toggle('disabled', isGloballyLoading);
    if (elements.addUrlModalButton) elements.addUrlModalButton.disabled = isGloballyLoading;
    if (elements.editNoteButton) elements.editNoteButton.disabled = isGloballyLoading;
    if (elements.viewNoteButton) elements.viewNoteButton.disabled = isGloballyLoading;
    if (elements.markdownTipsButton) elements.markdownTipsButton.disabled = isGloballyLoading;
    if (elements.micButtonNotes) elements.micButtonNotes.disabled = isGloballyLoading;
    if (elements.cleanupTranscriptButtonNotes) elements.cleanupTranscriptButtonNotes.disabled = isGloballyLoading;
    if (elements.longRecButtonNotes) elements.longRecButtonNotes.disabled = isGloballyLoading;
    
    // Notes Search Elements
    if (elements.notesSearchIconBtn) elements.notesSearchIconBtn.disabled = isGloballyLoading;
    if (elements.notesSearchInput) {
        // Keep search input enabled if search is active, otherwise disable based on global loading
        elements.notesSearchInput.disabled = state.isNoteSearchActive ? false : isGloballyLoading;
    }
    if (elements.notesSearchClearBtn) elements.notesSearchClearBtn.disabled = isGloballyLoading;
 
    document.querySelectorAll('.list-item').forEach(item => {
        if (isGloballyLoading) {
            item.classList.add('pointer-events-none', 'opacity-50');
        } else {
            item.classList.remove('pointer-events-none', 'opacity-50');
        }
    });
 
    elements.bodyElement?.classList.toggle('loading', isGloballyLoading);
    updateAttachButtonState();
}

/**
 * Renders the chat history from the state into the chatbox.
 */
export function renderChatHistory() {
    if (!elements.chatbox) {
        console.error("Chatbox element not found for rendering history.");
        return;
    }

    elements.chatbox.innerHTML = ''; // Clear current messages

    if (state.chatHistory.length === 0) {
        // Add a placeholder message if history is empty
        addMessageToDom({ // Pass object for consistency
            role: 'system',
            content: state.isLoading ? 'Loading chat history...' : 'This chat is empty. Start typing!',
            isError: false,
            attachments: [] // System messages typically don't have attachments
        });
    } else {
        state.chatHistory.forEach(msg => {
            // Pass the entire message object to addMessageToDom
            // This object should include role, content, isError, and attachments
            addMessageToDom(msg);
        });
    }

    // Auto-scroll to the bottom after rendering
    elements.chatbox.scrollTop = elements.chatbox.scrollHeight;
}

/**
 * Adds a single message to the chatbox DOM.
 * @param {object} messageObject - The message object.
 *   Expected properties: role, content, isError (optional), attachments (optional array), rawContent (optional for copy).
 * @returns {HTMLElement|null} The message element that was created.
 */
function addMessageToDom(messageObject) {
     if (!elements.chatbox) {
        console.error("Chatbox element not found.");
        return null;
    }

    // Destructure properties from the messageObject
    const { role, content, isError = false, attachments = [], rawContent: messageRawContent } = messageObject;

    const messageElement = document.createElement('div');
    // Add base classes, role-specific class, and flex for stacking attachments and content
    messageElement.classList.add('message', `${role}-msg`, 'p-3', 'mb-2', 'rounded-lg', 'whitespace-pre-wrap', 'relative', 'flex', 'flex-col');

    // Store raw content for copying (should be just the text part)
    const textToCopy = messageRawContent || (typeof content === 'string' ? content : "Complex content");
    messageElement.dataset.rawContent = textToCopy;


    // --- Render Attachments (if any) ---
    if (attachments && attachments.length > 0) {
        const attachmentsContainer = document.createElement('div');
        attachmentsContainer.classList.add('message-attachments-container', 'mb-2', 'flex', 'flex-wrap', 'gap-2'); // Styles for layout

        attachments.forEach(attachment => {
            if (attachment && attachment.filename) { // Ensure filename exists
                const attachmentElement = document.createElement('div');
                attachmentElement.classList.add(
                    'message-attachment-tag', 'inline-flex', 'items-center', 'text-xs', 'font-medium',
                    'px-2', 'py-0.5', 'rounded-full', 'bg-gray-100', 'text-gray-700',
                    'dark:bg-gray-600', 'dark:text-gray-200', // Example dark mode styling
                    'cursor-pointer', 'hover:bg-gray-200', 'dark:hover:bg-gray-500' // Make it clickable
                );
                attachmentElement.title = `Click to view: ${escapeHtml(attachment.filename)}`;
                // Store file ID and type for click handler
                if (attachment.id) { // Only add data-file-id if it's a saved file (not session)
                    attachmentElement.dataset.fileId = attachment.id;
                }
                attachmentElement.dataset.fileType = attachment.type; // 'full', 'summary', 'session'

                let iconClass = 'fa-file'; // Default icon
                // Determine icon based on attachment.type or attachment.mimetype
                if (attachment.type === 'session') {
                    iconClass = 'fa-paperclip';
                } else if (attachment.mimetype && attachment.mimetype.startsWith('image/')) {
                    iconClass = 'fa-file-image';
                } else if (attachment.mimetype === 'application/pdf') {
                    iconClass = 'fa-file-pdf';
                } else if (attachment.type === 'summary') { // Assuming 'type' is passed in attachment object
                    iconClass = 'fa-file-alt';
                } else if (attachment.type === 'full') {
                    iconClass = 'fa-file-invoice'; // Example, choose appropriate
                }
                // Add more specific icons as needed

                const iconElement = document.createElement('i');
                iconElement.className = `fas ${iconClass} mr-1.5`;

                const nameSpan = document.createElement('span');
                nameSpan.textContent = escapeHtml(attachment.filename);

                attachmentElement.appendChild(iconElement);
                attachmentElement.appendChild(nameSpan);
                attachmentsContainer.appendChild(attachmentElement);

                // Add click listener to the attachment tag
                attachmentElement.addEventListener('click', async () => {
                    const fileId = attachmentElement.dataset.fileId;
                    const fileType = attachmentElement.dataset.fileType;

                    if (fileType === 'session') {
                        // Handle session file display (content is stored in the attachment object in chatHistory)
                        console.log(`[DEBUG] Displaying session file content for ${attachment.filename}`);
                        // The attachment object for session files now includes 'content'
                        const sessionFileContent = attachment.content; // This is a data URL
                        const sessionFileMimetype = attachment.mimetype;
                        const sessionFilename = attachment.filename;

                        if (sessionFileContent !== undefined && sessionFileContent !== null) {
                             // For session files, content is already a data URL.
                             // The isBase64 flag for setCurrentViewingFile should reflect if the *original* data was binary,
                             // not whether the dataURL itself is base64 (it always is).
                             // The `isText` check here determines if the original was likely text.
                             const isText = sessionFileMimetype.startsWith('text/') || sessionFileMimetype === 'application/json' || /\.(txt|py|js|html|css|md|json|csv)$/i.test(sessionFilename);
                             state.setCurrentViewingFile(
                                 'session', // Use a placeholder ID for session files
                                 sessionFilename,
                                 sessionFileContent, // Pass the data URL directly
                                 sessionFileMimetype,
                                 false // For data URLs, the content itself is not "raw base64" in the same way backend files are.
                                        // The rendering function will handle data URLs.
                             );
                             showModal(elements.fileContentModal);
                        } else {
                             console.error("Session file content not found in attachment object for display.", attachment);
                             // Maybe show an error toast?
                        }

                    } else if (fileId) {
                        // Handle saved file display (fetch content from backend)
                        console.log(`[DEBUG] Fetching content for file ID: ${fileId}`);
                        // Dynamically import api.js to avoid circular dependencies if ui.js is imported by api.js
                        const apiModule = await import('./api.js');
                        const fileData = await apiModule.fetchFileContent(parseInt(fileId));

                        if (fileData && fileData.content !== undefined) {
                            state.setCurrentViewingFile(
                                fileData.id,
                                fileData.filename,
                                fileData.content,
                                fileData.mimetype,
                                fileData.is_base64 // This flag from backend indicates if content is raw base64
                            );
                            showModal(elements.fileContentModal);
                        } else {
                            // Error message already handled by fetchFileContent
                        }
                    } else {
                        console.warn("Clicked attachment tag has no file ID or is not a session file.", attachment);
                    }
                });
            }
        });
        messageElement.appendChild(attachmentsContainer); // Add attachments before message content
    }
    // --- END: Render Attachments ---


    if (isError) {
        messageElement.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-400', 'dark:bg-red-900', 'dark:text-red-300');
        const errorContentDiv = document.createElement('div'); // Create a div for content
        errorContentDiv.innerHTML = `<strong>Error:</strong> ${escapeHtml(content)}`;
        messageElement.appendChild(errorContentDiv);
    } else {
         const messageContentDiv = document.createElement('div'); // Create a div for main content
         if (typeof marked !== 'undefined') {
             let rawHtml = marked.parse(content || '', { renderer: markedRenderer, ...config.markedOptions }); // Ensure content is not null
             const tempContainer = document.createElement('div');
             tempContainer.innerHTML = rawHtml;
             const codeBlocks = tempContainer.querySelectorAll('pre > code.language-xml, pre > code.language-drawio');
             const replacements = [];
             codeBlocks.forEach((codeBlock) => {
                 const parentPre = codeBlock.parentElement;
                 const xmlContent = codeBlock.textContent || '';
                 if (xmlContent.includes('<mxfile') && xmlContent.includes('</mxfile>')) {
                     const graphDiv = document.createElement('div');
                     graphDiv.className = 'mxgraph';
                     graphDiv.setAttribute('style', 'max-width: 100%; border: 1px solid transparent;');
                     graphDiv.setAttribute('data-mxgraph', JSON.stringify({
                         highlight: '#0000ff', nav: true, resize: true, toolbar: 'zoom layers lightbox', xml: xmlContent
                     }));
                     replacements.push({ oldNode: parentPre, newNode: graphDiv });
                 }
             });
             replacements.forEach(rep => {
                 if (rep.oldNode && rep.oldNode.parentNode) {
                     rep.oldNode.parentNode.replaceChild(rep.newNode, rep.oldNode);
                 }
             });
             rawHtml = tempContainer.innerHTML;
             const collapsibleFragment = makeHeadingsCollapsible(rawHtml);
             messageContentDiv.appendChild(collapsibleFragment);

             // Initialize List.js for any tables within the message content
             const messageIdForTable = messageObject.id || `msg-${Date.now()}`;
             initializeListJsForTables(messageContentDiv, `chat-${messageIdForTable}`);

             setTimeout(() => { waitForGraphViewerAndProcess(); }, 50);
         } else {
             messageContentDiv.textContent = content || ''; // Fallback, ensure content is not null
         }
         messageElement.appendChild(messageContentDiv); // Append the content div

        // Apply role-specific styling
        if (role === 'user') {
            messageElement.classList.add('bg-blue-100', 'self-end', 'dark:bg-blue-800');
        } else if (role === 'assistant') {
            messageElement.classList.add('bg-gray-200', 'self-start', 'dark:bg-gray-700');
        } else if (role === 'system') {
             messageElement.classList.add('bg-yellow-100', 'text-yellow-800', 'self-center', 'text-center', 'italic', 'dark:bg-yellow-700', 'dark:text-yellow-200');
        }

        // Add copy button only for user and assistant messages (not system or error)
        if ((role === 'user' || role === 'assistant') && !isError) {
            const copyButton = document.createElement('button');
            copyButton.classList.add('copy-message-button');
            copyButton.title = 'Copy raw text';
            copyButton.innerHTML = '<i class="far fa-copy"></i>';
            // Position copy button absolutely within the messageElement (which is relative)
            copyButton.style.position = 'absolute';
            copyButton.style.bottom = '0.25rem'; // <<< CHANGED from top to bottom
            copyButton.style.right = '0.25rem'; // Keep right positioning
            messageElement.appendChild(copyButton);
        }
    }
    elements.chatbox.appendChild(messageElement);
    return messageElement;
}


/**
 * Renders the list of saved chats from the state in the sidebar.
 */
export function renderSavedChats() {
    const { savedChatsList, currentChatNameInput, currentChatIdDisplay } = elements;
    if (!savedChatsList) return;

    savedChatsList.innerHTML = ''; // Clear current list

    const chats = state.savedChats; // Read from state

    if (!chats || chats.length === 0) {
        savedChatsList.innerHTML = '<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No saved chats yet.</p>';
        // Reset current chat display if no chats exist and one was selected
        if (state.currentChatId !== null) {
             if (currentChatNameInput) currentChatNameInput.value = '';
             if (currentChatIdDisplay) currentChatIdDisplay.textContent = 'ID: -';
             // State is already cleared by API/event listener
        }
        return;
    }

    // Sort chats by last_updated_at descending
    const sortedChats = chats.sort((a, b) => new Date(b.last_updated_at) - new Date(a.last_updated_at));

    sortedChats.forEach(chat => createChatItem(chat)); // Use helper

    // Update highlighting after rendering
    updateActiveChatListItem();
}

/**
 * Helper to create chat list item DOM element.
 * @param {Object} chat - The chat object { id, name, last_updated_at }.
 * @returns {HTMLElement} The created div element.
 */
function createChatItem(chat) {
    const { savedChatsList } = elements;
    if (!savedChatsList) return;

    const listItem = document.createElement('div');
    // Use 'active' class for selection as per CORRECT HTML
    listItem.classList.add('list-item', 'chat-list-item', 'p-2', 'border-rz-sidebar-border', 'cursor-pointer', 'hover:bg-rz-sidebar-hover'); // Removed flex, items-center, truncate, flex-grow, p-1
    listItem.dataset.chatId = chat.id;

    // Container for name and delete button (flex row)
    // Use 'name-container' class as per CORRECT HTML
    const nameDeleteContainer = document.createElement('div');
    nameDeleteContainer.classList.add('name-container'); // Use specific class

    const nameSpan = document.createElement('span');
    // Use only 'filename' class as per CORRECT HTML - color handled by CSS
    // Remove truncate and flex-grow as they conflict with list-item's column flex
    nameSpan.classList.add('filename'); // Use specific class
    nameSpan.textContent = chat.name || `Chat ${chat.id}`;
    nameSpan.title = chat.name || `Chat ${chat.id}`; // Add title for tooltip

    // Add delete button
    // Use only 'delete-btn' class as per CORRECT HTML - color handled by CSS
    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-btn', 'text-rz-sidebar-text'); // Use specific class
    deleteButton.innerHTML = '<i class="fas fa-trash-alt fa-xs"></i>'; // Use fa-xs as per CORRECT HTML
    deleteButton.title = `Delete "${chat.name || `Chat ${chat.id}`}"`;

    nameDeleteContainer.appendChild(nameSpan);
    nameDeleteContainer.appendChild(deleteButton); // Append delete button

    // Add timestamp div
    // Use 'div' and specific classes as per CORRECT HTML - color handled by CSS
    const timestampDiv = document.createElement('div');
    // Default color is text-rz-tab-background-text (greyish) based on provided HTML
    timestampDiv.classList.add('text-xs', 'mt-0.5', 'text-rz-toolbar-field-text'); // Use specific classes and mt-0.5 - color handled by CSS
    try {
        const date = new Date(chat.last_updated_at);
        // Format date nicely, e.g., "Oct 26, 10:30 AM" or "Yesterday, 3:15 PM"
        const now = new Date();
        const yesterday = new Date(now);
        yesterday.setDate(now.getDate() - 1);

        let formattedDate;
        if (date.toDateString() === now.toDateString()) {
            formattedDate = `Today, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
        } else if (date.toDateString() === yesterday.toDateString()) {
            formattedDate = `Yesterday, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
        } else {
            formattedDate = date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ', ' + date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        }
        // Prepend "Last updated: " as per CORRECT HTML
        timestampDiv.textContent = `Last updated: ${formattedDate}`;
    } catch (e) {
        console.error("Error formatting date:", chat.last_updated_at, e);
        timestampDiv.textContent = 'Last updated: Invalid Date';
    }


    listItem.appendChild(nameDeleteContainer); // Append the container
    listItem.appendChild(timestampDiv); // Append the timestamp div

    savedChatsList.appendChild(listItem);
}


/** Updates the highlighting for the currently active chat list item based on state. */
export function updateActiveChatListItem() {
    const { savedChatsList } = elements;
    if (!savedChatsList) return;

    savedChatsList.querySelectorAll('.chat-list-item').forEach(item => {
        const chatId = parseInt(item.dataset.chatId);
        // Find the timestamp div (it has text-xs class)
        const timestampDiv = item.querySelector('.text-xs');

        // Use 'active' class as per CORRECT HTML
        if (chatId === state.currentChatId) { // Read from state
            item.classList.add('active'); // Use 'active'
            item.classList.remove('active-selection'); // Remove old class

            // When active, timestamp should be gold (text-rz-sidebar-text)
            if (timestampDiv) {
                timestampDiv.classList.add('text-rz-sidebar-text', 'active-timestamp');
                timestampDiv.classList.remove('text-rz-tab-background-text');
            }
            // Trash can icon should also change color when selected
            const deleteButton = item.querySelector('.delete-btn');
            if (deleteButton) {
                deleteButton.classList.add('active-trash');
            }
            // Scroll the active item into view if it's not already visible
            item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
            item.classList.remove('active'); // Use 'active'
            item.classList.remove('active-selection'); // Remove old class

            // When inactive, timestamp should be greyish (text-rz-tab-background-text)
            if (timestampDiv) {
                timestampDiv.classList.remove('text-rz-sidebar-text', 'active-timestamp');
                timestampDiv.classList.add('text-rz-tab-background-text');
            }
            // Trash can icon should revert to default color when not selected
            const deleteButton = item.querySelector('.delete-btn');
            if (deleteButton) {
                deleteButton.classList.remove('active-trash');
            }
        }
    });
}

/**
 * Renders the current chat's name and ID from the state.
 */
export function renderCurrentChatDetails() {
    const { currentChatNameInput, currentChatIdDisplay, modelSelector } = elements;
    // Add null checks for individual elements
    if (currentChatNameInput) currentChatNameInput.value = state.currentChatName || ''; // Read from state
    if (currentChatIdDisplay) currentChatIdDisplay.textContent = state.currentChatId !== null ? `ID: ${state.currentChatId}` : 'ID: -'; // Read from state
    if (modelSelector) modelSelector.value = state.currentChatModel || modelSelector.options[0]?.value || ''; // Read from state
}

/** Adds/Removes a processing indicator (e.g., spinner) to chat list items. */
export function updateChatListProcessingIndicator() {
    const { savedChatsList } = elements;
    if (!savedChatsList) return;

    savedChatsList.querySelectorAll('.chat-list-item').forEach(item => {
        const chatId = parseInt(item.dataset.chatId);
        const nameContainer = item.querySelector('.name-container'); // Find the container for name/delete
        let spinner = item.querySelector('.processing-spinner'); // Check if spinner exists

        if (chatId === state.processingChatId) {
            // Add spinner if it doesn't exist
            if (!spinner && nameContainer) {
                spinner = document.createElement('span');
                spinner.classList.add('processing-spinner', 'ml-2'); // Add margin-left
                spinner.innerHTML = '<i class="fas fa-spinner fa-spin fa-xs text-rz-sidebar-text"></i>'; // Spinner icon
                // Insert spinner after the name span within the name container
                const nameSpan = nameContainer.querySelector('.filename');
                if (nameSpan) {
                    nameSpan.insertAdjacentElement('afterend', spinner);
                } else {
                    nameContainer.appendChild(spinner); // Fallback append
                }
            }
            item.classList.add('processing'); // Add class for potential styling
        } else {
            // Remove spinner if it exists
            if (spinner) {
                spinner.remove();
            }
            item.classList.remove('processing'); // Remove class
        }
    });
}

/**
 * Renders the list of saved notes from the state in the sidebar.
 */
export function renderSavedNotes() {
    const { savedNotesList, currentNoteNameInput, currentNoteIdDisplay } = elements;
    if (!savedNotesList) return;

    // If note search is active, this function should not clear and re-render the normal list.
    // The rendering of search results will be handled by a different function.
    if (state.isNoteSearchActive) {
        console.log("[UI DEBUG] renderSavedNotes: Search is active, skipping normal render.");
        return;
    }

    savedNotesList.innerHTML = ''; // Clear current list

    const notes = state.savedNotes; // Read from state

    if (!notes || notes.length === 0) {
        savedNotesList.innerHTML = '<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No saved notes yet.</p>';
         // Reset current note display if no notes exist and one was selected
        if (state.currentNoteId !== null) {
             if (currentNoteNameInput) currentNoteNameInput.value = '';
             if (currentNoteIdDisplay) currentNoteIdDisplay.textContent = 'ID: -';
             // State is already cleared by API/event listener
        }
        return;
    }

    // Sort notes by last_saved_at descending
    const sortedNotes = notes.sort((a, b) => new Date(b.last_saved_at) - new Date(a.last_saved_at));

    sortedNotes.forEach(note => createNoteItem(note)); // Use helper

    // Update highlighting after rendering
    updateActiveNoteListItem();
}

/**
 * Helper to create note list item DOM element.
 * @param {Object} note - The note object { id, name, last_saved_at }.
 * @returns {HTMLElement} The created div element.
 */
function createNoteItem(note) {
    const { savedNotesList } = elements;
    if (!savedNotesList) return;

    const listItem = document.createElement('div');
    // Note items use 'active' class for selection as per provided HTML
    listItem.classList.add('list-item', 'note-list-item', 'p-2', 'border-rz-sidebar-border', 'cursor-pointer', 'hover:bg-rz-sidebar-hover'); // Removed flex, items-center, truncate, flex-grow, p-1
    listItem.dataset.noteId = note.id;

    // Container for name and delete button (flex row)
    // Use 'name-container' class as per provided HTML
    const nameDeleteContainer = document.createElement('div');
    nameDeleteContainer.classList.add('name-container'); // Use specific class

    const nameSpan = document.createElement('span');
    // Use only 'filename' class as per provided HTML - color handled by CSS
    // Remove truncate and flex-grow as they conflict with list-item's column flex
    nameSpan.classList.add('filename'); // Use specific class
    nameSpan.textContent = note.name || `Note ${note.id}`;
    nameSpan.title = note.name || `Note ${note.id}`; // Add title for tooltip

    // Add delete button
    // Use only 'delete-btn' class as per CORRECT HTML - color handled by CSS
    const deleteButton = document.createElement('button');
    deleteButton.classList.add('delete-btn', 'text-rz-sidebar-text'); // Use specific class
    deleteButton.innerHTML = '<i class="fas fa-trash-alt fa-xs"></i>'; // Use fa-xs as per provided HTML
    deleteButton.title = `Delete "${note.name || `Note ${note.id}`}"`;

    nameDeleteContainer.appendChild(nameSpan);
    nameDeleteContainer.appendChild(deleteButton); // Append delete button

    // Add timestamp div
    // Use 'div' and specific classes as per CORRECT HTML - color handled by CSS
    const timestampDiv = document.createElement('div');
    // Default color is text-rz-tab-background-text (greyish) based on provided HTML
    timestampDiv.classList.add('text-xs', 'mt-0.5', 'text-rz-toolbar-field-text'); // Use specific classes and mt-0.5 - color handled by CSS
    try {
        const date = new Date(note.last_saved_at); // Use uploaded_at for files
        // Format date nicely, e.g., "Oct 26, 10:30 AM" or "Yesterday, 3:15 PM"
        const now = new Date();
        const yesterday = new Date(now);
        yesterday.setDate(now.getDate() - 1);

        let formattedDate;
        if (date.toDateString() === now.toDateString()) {
            formattedDate = `Today, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
        } else if (date.toDateString() === yesterday.toDateString()) {
            formattedDate = `Yesterday, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
        } else {
            formattedDate = date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ', ' + date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        }
        // Prepend "Last saved: " as per provided HTML
        timestampDiv.textContent = `Last saved: ${formattedDate}`;
    } catch (e) {
        console.error("Error formatting date:", note.last_saved_at, e);
        timestampDiv.textContent = 'Last saved: Invalid Date';
    }

    listItem.appendChild(nameDeleteContainer); // Append the container
    listItem.appendChild(timestampDiv); // Append the timestamp div

    savedNotesList.appendChild(listItem);
}


/** Updates the highlighting for the currently active note list item based on state. */
export function updateActiveNoteListItem() {
    const { savedNotesList } = elements;
    if (!savedNotesList) return;

    savedNotesList.querySelectorAll('.note-list-item').forEach(item => {
        const noteId = parseInt(item.dataset.noteId);
        // Find the timestamp div (it has text-xs class)
        const timestampDiv = item.querySelector('.text-xs');

        // Use 'active' class as per provided HTML
        if (noteId === state.currentNoteId) { // Read from state
            item.classList.add('active'); // Use 'active'
            item.classList.remove('active-selection'); // Remove old class

            // When active, timestamp should be gold (text-rz-sidebar-text)
            if (timestampDiv) {
                timestampDiv.classList.add('text-rz-sidebar-text', 'active-timestamp');
                timestampDiv.classList.remove('text-rz-tab-background-text');
            }
             // Trash can icon should also change color when selected
            const deleteButton = item.querySelector('.delete-btn');
            if (deleteButton) {
                deleteButton.classList.add('active-trash');
            }
            // Scroll the active item into view if it's not already visible
            item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        } else {
            item.classList.remove('active'); // Use 'active'
            item.classList.remove('active-selection'); // Remove old class

            // When inactive, timestamp should be greyish (text-rz-tab-background-text)
            if (timestampDiv) {
                timestampDiv.classList.remove('text-rz-sidebar-text', 'active-timestamp');
                timestampDiv.classList.add('text-rz-tab-background-text');
            }
            // Trash can icon should revert to default color when not selected
            const deleteButton = item.querySelector('.delete-btn');
            if (deleteButton) {
                deleteButton.classList.remove('active-trash');
            }
        }
    });
}

/**
 * Renders the current note's name and ID from the state.
 */
export function renderCurrentNoteDetails() {
    const { currentNoteNameInput, currentNoteIdDisplay } = elements;
    // Add null checks for individual elements
    if (currentNoteNameInput) currentNoteNameInput.value = state.currentNoteName || ''; // Read from state
    if (currentNoteIdDisplay) currentNoteIdDisplay.textContent = state.currentNoteId !== null ? `ID: ${state.currentNoteId}` : 'ID: -'; // Read from state
}

/**
 * Renders the current note's content from the state into the textarea and preview.
 */
export function renderNoteContent() {
    const { notesTextarea, notesPreview } = elements;
    // Add null checks for individual elements
    if (notesTextarea) {
        notesTextarea.value = state.noteContent || ''; // Read from state
        notesTextarea.placeholder = state.isLoading ? "Loading note..." : "Start typing your markdown notes here...";
        notesTextarea.disabled = state.isLoading || state.currentNoteId === null; // Disable if loading or no note loaded
        autoResizeTextarea(notesTextarea);
    }


    if (notesPreview) {
        updateNotesPreview();
    }
}


/**
 * Renders the list of uploaded files from the state in the plugins sidebar and manage files modal.
 */
export function renderUploadedFiles() {
    const { uploadedFilesList, manageFilesList } = elements;
    if (!uploadedFilesList || !manageFilesList) return;

    uploadedFilesList.innerHTML = '';
    manageFilesList.innerHTML = '';

    const files = state.uploadedFiles;

    if (!files || files.length === 0) {
        uploadedFilesList.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No files uploaded yet.</p>`;
        manageFilesList.innerHTML = `<p class="text-gray-500 text-xs p-1">No files uploaded yet.</p>`;
        return;
    }

    files.forEach(file => {
        const isSidebarSelected = state.sidebarSelectedFiles.some(sf => sf.id === file.id);
        createSidebarFileItem(file, isSidebarSelected);
        createModalFileItem(file);
    });

    renderAttachedAndSessionFiles();
    updateAttachButtonState();
}

/**
 * Creates a DOM element for a file item in the sidebar list.
 * @param {Object} file - The file object { id, filename, mimetype, filesize, has_summary }.
 * @param {boolean} isSelected - Whether the file is currently selected in the sidebar.
 * @returns {HTMLElement} The created div element.
 */
function createSidebarFileItem(file, isSelected) {
    const { uploadedFilesList } = elements;
    if (!uploadedFilesList) return;

    const itemDiv = document.createElement('div');
    itemDiv.classList.add('list-item', 'file-list-item', 'p-2', 'border-rz-sidebar-border', 'cursor-pointer', 'hover:bg-rz-sidebar-hover');
    itemDiv.dataset.fileId = file.id;
    itemDiv.dataset.filename = file.filename;
    itemDiv.dataset.hasSummary = file.has_summary;
    if (isSelected) {
        itemDiv.classList.add('active');
    }


    const nameContainer = document.createElement('div');
    nameContainer.classList.add('name-container');

    const nameSpan = document.createElement('span');
    nameSpan.classList.add('filename');
    nameSpan.textContent = file.filename;
    nameSpan.title = file.filename;

    nameContainer.appendChild(nameSpan);

    const timestampDiv = document.createElement('div');
    timestampDiv.classList.add('text-xs', 'mt-0.5', 'text-rz-toolbar-field-text');
    try {
        const date = new Date(file.uploaded_at);
        const now = new Date();
        const yesterday = new Date(now);
        yesterday.setDate(now.getDate() - 1);

        let formattedDate;
        if (date.toDateString() === now.toDateString()) {
            formattedDate = `Today, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
        } else if (date.toDateString() === yesterday.toDateString()) {
            formattedDate = `Yesterday, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
        } else {
            formattedDate = date.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ', ' + date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        }
        timestampDiv.textContent = `Uploaded: ${formattedDate}`;
    } catch (e) {
        console.error("Error formatting date:", file.uploaded_at, e);
        timestampDiv.textContent = 'Uploaded: Invalid Date';
    }


    itemDiv.appendChild(nameContainer);
    itemDiv.appendChild(timestampDiv);

    uploadedFilesList.appendChild(itemDiv);
}

/**
 * Updates the highlighting for selected file list items in the sidebar based on state.
 * Multiple files can be selected.
 */
export function updateSelectedFileListItemStyling() {
    const { uploadedFilesList } = elements;
    if (!uploadedFilesList) return;

    uploadedFilesList.querySelectorAll('.file-list-item').forEach(item => {
        const fileId = parseInt(item.dataset.fileId);
        if (isNaN(fileId)) return;

        const isSelected = state.sidebarSelectedFiles.some(sf => sf.id === fileId);

        if (isSelected) {
            item.classList.add('active');
        } else {
            item.classList.remove('active');
        }
    });
}

/**
 * Updates the enabled/disabled state of the Attach Full and Attach Summary buttons
 * based on the state of files selected in the sidebar.
 */
export function updateAttachButtonState() {
    const { attachFullButton, attachSummaryButton } = elements;
    if (!attachFullButton || !attachSummaryButton) return;

    const selectedCount = state.sidebarSelectedFiles.length;
    console.log(`[DEBUG] updateAttachButtonState: selectedCount=${selectedCount}, isLoading=${state.isLoading}`);
    console.log(`[DEBUG] updateAttachButtonState: state.sidebarSelectedFiles=`, JSON.parse(JSON.stringify(state.sidebarSelectedFiles)));


    attachFullButton.disabled = state.isLoading || selectedCount === 0;
    attachSummaryButton.disabled = state.isLoading || selectedCount === 0;
}


/**
 * Creates a DOM element for a file item in the Manage Files modal list.
 * @param {Object} file - The file object { id, filename, mimetype, filesize, has_summary, uploaded_at }.
 */
function createModalFileItem(file) {
    const { manageFilesList } = elements;
     if (!manageFilesList) return;

    const itemDiv = document.createElement('div');
    itemDiv.classList.add('file-list-item', 'grid', 'grid-cols-12', 'gap-2', 'items-center', 'p-2', 'border-b', 'border-gray-200', 'last:border-b-0', 'text-sm');
    itemDiv.dataset.fileId = file.id;
    itemDiv.dataset.filename = file.filename;
    itemDiv.dataset.hasSummary = file.has_summary;

    const nameCol = document.createElement('div');
    nameCol.classList.add('col-span-7', 'text-sm', 'text-gray-800', 'truncate');
    nameCol.textContent = file.filename;
    nameCol.title = file.filename;

    const sizeCol = document.createElement('div');
    sizeCol.classList.add('col-span-2', 'text-xs', 'text-gray-500');
    sizeCol.textContent = formatFileSize(file.filesize);

    const actionsCol = document.createElement('div');
    actionsCol.classList.add('col-span-3', 'flex', 'gap-1', 'justify-end');

    const summaryButton = document.createElement('button');
    summaryButton.classList.add('btn', 'btn-outline', 'btn-xs', 'p-1');
    summaryButton.innerHTML = '<i class="fas fa-list-alt"></i>';
    summaryButton.title = file.has_summary ? 'View/Edit Summary' : 'Generate Summary';

    const deleteButton = document.createElement('button');
    deleteButton.classList.add('btn', 'btn-outline', 'btn-xs', 'p-1', 'text-red-500', 'hover:text-red-700');
    deleteButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
    deleteButton.title = 'Delete File';

    actionsCol.appendChild(summaryButton);
    actionsCol.appendChild(deleteButton);
    itemDiv.appendChild(nameCol);
    itemDiv.appendChild(sizeCol);
    itemDiv.appendChild(actionsCol);
    manageFilesList.appendChild(itemDiv);
}

/**
 * Renders the content of the summary modal based on state.
 */
export function renderSummaryModalContent() {
    const { summaryModalFilename, summaryTextarea, saveSummaryButton, summaryStatus } = elements;
    if (!summaryModalFilename || !summaryTextarea || !saveSummaryButton || !summaryStatus) return;

    const file = state.uploadedFiles.find(f => f.id === state.currentEditingFileId);
    const filename = file ? file.filename : 'Unknown File';

    summaryModalFilename.textContent = filename;
    summaryTextarea.value = state.summaryContent;
    summaryTextarea.placeholder = state.isLoading ? "Loading or generating summary..." : "Enter or edit summary here.";
    saveSummaryButton.disabled = state.isLoading || state.currentEditingFileId === null;

    if (state.isLoading && state.statusMessage.includes("Fetching Summary")) {
         summaryStatus.textContent = "Fetching...";
         summaryStatus.classList.remove('text-red-500');
    } else if (state.isLoading && state.statusMessage.includes("Saving Summary")) {
         summaryStatus.textContent = "Saving...";
         summaryStatus.classList.remove('text-red-500');
    } else if (state.isErrorStatus && state.statusMessage.includes("summary")) {
         summaryStatus.textContent = `Error: ${state.statusMessage}`;
         summaryStatus.classList.add('text-red-500');
    } else if (state.summaryContent.startsWith("[Error") || state.summaryContent.startsWith("[Summary not applicable")) {
         summaryStatus.textContent = state.summaryContent;
         summaryStatus.classList.add('text-red-500');
         saveSummaryButton.disabled = state.summaryContent.startsWith("[Summary not applicable");
    }
    else {
         summaryStatus.textContent = "Summary loaded. You can edit and save changes.";
         summaryStatus.classList.remove('text-red-500');
    }
}


/**
 * Renders the list of currently attached files and the session file below the message input.
 */
export function renderAttachedAndSessionFiles() {
    const { selectedFilesContainer, fileUploadSessionInput } = elements;
    if (!selectedFilesContainer) return;

    selectedFilesContainer.innerHTML = ''; // Clear current display

    const filesToDisplay = [];
    if (state.sessionFile) {
        filesToDisplay.push({
            id: 'session',
            filename: state.sessionFile.filename || state.sessionFile.name,
            type: 'session',
            mimetype: state.sessionFile.mimetype || state.sessionFile.type,
        });
    }
    state.attachedFiles.forEach(file => {
        filesToDisplay.push({
            id: file.id,
            filename: file.filename,
            type: file.type,
            mimetype: file.mimetype,
        });
    });


    if (filesToDisplay.length === 0) {
        selectedFilesContainer.classList.add('hidden');
        if (!state.sessionFile && fileUploadSessionInput) {
             fileUploadSessionInput.value = '';
        }
        return;
    }

    selectedFilesContainer.classList.remove('hidden');

    filesToDisplay.forEach(file => {
        const fileTag = document.createElement('span');
        fileTag.classList.add('selected-file-tag', 'inline-flex', 'items-center', 'text-xs', 'font-medium', 'px-2.5', 'py-0.5', 'rounded-full', 'mr-2', 'mb-1');
        fileTag.dataset.fileId = file.id;
        fileTag.dataset.fileType = file.type;

        if (file.type === 'session') {
             fileTag.classList.add('bg-rz-tag-bg', 'text-rz-tag-text', 'border', 'border-rz-tag-border');
        } else {
             fileTag.classList.add('bg-rz-button-primary-bg', 'text-rz-button-primary-text');
        }

        const filenameSpan = document.createElement('span');
        filenameSpan.textContent = escapeHtml(file.filename);
        filenameSpan.classList.add('mr-1');

        const typeSpan = document.createElement('span');
        typeSpan.classList.add('file-type');
        let typeText = 'File';
        if (file.type === 'full') typeText = 'Full';
        else if (file.type === 'summary') typeText = 'Summary';
        else if (file.type === 'session') typeText = 'Session';
        typeSpan.textContent = typeText;
        filenameSpan.prepend(typeSpan);


        const removeButton = document.createElement('button');
        removeButton.classList.add('remove-file-btn', 'ml-1');
        removeButton.innerHTML = '<i class="fas fa-times-circle"></i>';
        removeButton.title = `Remove ${file.type === 'session' ? 'session' : 'attached'} file`;
        removeButton.addEventListener('click', () => {
            if (file.type === 'session') {
                state.setSessionFile(null);
                if (elements.fileUploadSessionInput) {
                    elements.fileUploadSessionInput.value = '';
                }
            } else {
                state.removeAttachedFileByIdAndType(parseInt(file.id), file.type);
            }
        });

        fileTag.appendChild(filenameSpan);
        fileTag.appendChild(removeButton);
        selectedFilesContainer.appendChild(fileTag);
    });
}


/**
 * Shows a modal window.
 * @param {HTMLElement} modalElement - The modal element to show.
 * @param {string} [requiredPlugin=null] - Optional plugin key ('files', 'calendar', etc.) required to show the modal.
 * @param {string} [requiredTab=null] - Optional tab key ('chat', 'notes') required to show the modal.
 * @returns {boolean} True if the modal was shown, false otherwise.
 */
export function showModal(modalElement, requiredPlugin = null, requiredTab = null) {
    console.log('[UI DEBUG] showModal called. Modal Element ID:', modalElement ? modalElement.id : 'null'); // Log entry and element ID

    if (!modalElement) {
        console.error("Modal element not found.");
        return false;
    }

    if (requiredPlugin) {
        let pluginEnabled = false;
        if (requiredPlugin === 'files') pluginEnabled = true;
        else if (requiredPlugin === 'calendar' && state.isCalendarPluginEnabled) pluginEnabled = true;
        if (!pluginEnabled) return false;
    }

    if (requiredTab && state.currentTab !== requiredTab) return false;


    modalElement.classList.add('show');
    console.log('[UI DEBUG] showModal: Added "show" class. Modal classes:', modalElement.className); // Log classes after adding 'show'
    if (elements.bodyElement) elements.bodyElement.classList.add('modal-open');
    // Update state ONLY for file content modal, as other modals might have their own state flags
    if (modalElement.id === 'file-content-modal') {
        state.setIsFileContentModalOpen(true);
    }
    return true;
}


/**
 * Hides a modal window.
 * @param {HTMLElement} modalElement - The modal element to hide.
 */
export function hideModal(modalElement) {
    if (modalElement) {
        modalElement.classList.remove('show');
        // Check if *any* modal is still open before removing the body class
        const anyModalOpen = document.querySelectorAll('.modal.show').length > 0;
        if (!anyModalOpen && elements.bodyElement) elements.bodyElement.classList.remove('modal-open');

        // Specific cleanup for file content modal
        if (modalElement.id === 'file-content-modal') {
            state.setIsFileContentModalOpen(false); // Update state
            state.clearCurrentViewingFile(); // Clear viewing state
        }
         // Specific cleanup for summary modal
        if (modalElement.id === 'summary-modal') {
             state.setCurrentEditingFileId(null); // Clear editing state
             state.setSummaryContent(""); // Clear summary content state
        }
         // Specific cleanup for URL modal
        if (modalElement.id === 'url-modal') {
             if(elements.urlInput) elements.urlInput.value = ''; // Clear input
             if(elements.urlStatus) elements.urlStatus.textContent = ''; // Clear status
        }
         // Specific cleanup for settings modal
        if (modalElement.id === 'settings-modal') {
             // No specific state to clear currently
        }
         // Specific cleanup for markdown tips modal
        if (modalElement.id === 'markdown-tips-modal') {
             // No specific state to clear currently
        }

        console.log(`[DEBUG] Modal hidden: ${modalElement.id}`);
    }
}


/**
 * Toggles the collapsed state of a sidebar.
 * @param {HTMLElement} sidebarElement - The sidebar element.
 * @param {HTMLElement} toggleButton - The button that toggles the sidebar.
 * @param {boolean} isCollapsed - The desired state (true for collapsed).
 * @param {string} localStorageKey - The key to use for localStorage.
 * @param {'sidebar' | 'plugins'} type - The type of sidebar ('sidebar' or 'plugins').
 */
export function setSidebarCollapsed(sidebarElement, toggleButton, isCollapsed, localStorageKey, type) {
    if (!sidebarElement || !toggleButton) return;
    localStorage.setItem(localStorageKey, isCollapsed);
    if (type === 'sidebar') state.setIsSidebarCollapsed(isCollapsed);
    else if (type === 'plugins') state.setIsPluginsCollapsed(isCollapsed);
}


/** Toggles the left sidebar (chat/notes list). */
export function toggleLeftSidebar() {
    const sidebarElement = document.getElementById('sidebar');
    const toggleButton = document.getElementById('sidebar-toggle-tab');
    if (!sidebarElement || !toggleButton) return;
    setSidebarCollapsed(sidebarElement, toggleButton, !sidebarElement.classList.contains('collapsed'), config.SIDEBAR_COLLAPSED_KEY, 'sidebar');
}

/** Toggles the right sidebar (plugins). */
export function toggleRightSidebar() {
    const sidebarElement = document.getElementById('plugins-sidebar');
    const toggleButton = document.getElementById('plugins-toggle-tab');
    if (!sidebarElement || !toggleButton) return;
    setSidebarCollapsed(sidebarElement, toggleButton, !sidebarElement.classList.contains('collapsed'), config.PLUGINS_COLLAPSED_KEY, 'plugins');
}

/** Toggles the File Plugin section. */
export function toggleFilePlugin() {
    if (!elements.filePluginHeader || !elements.filePluginContent) return;
    const isCollapsed = elements.filePluginContent.classList.contains('hidden');
    setPluginSectionCollapsed(elements.filePluginHeader, elements.filePluginContent, !isCollapsed, config.FILE_PLUGIN_COLLAPSED_KEY);
}

/** Toggles the Calendar Plugin section. */
export function toggleCalendarPlugin() {
    if (!elements.calendarPluginHeader || !elements.calendarPluginContent) return;
    const isCollapsed = elements.calendarPluginContent.classList.contains('hidden');
    setPluginSectionCollapsed(elements.calendarPluginHeader, elements.calendarPluginContent, !isCollapsed, config.CALENDAR_PLUGIN_COLLAPSED_KEY);
}

/** Toggles the History Plugin section. */
export function toggleHistoryPlugin() {
    if (!elements.historyPluginHeader || !elements.historyPluginContent) return;
    const isCollapsed = elements.historyPluginContent.classList.contains('hidden');
    setPluginSectionCollapsed(elements.historyPluginHeader, elements.historyPluginContent, !isCollapsed, config.HISTORY_PLUGIN_COLLAPSED_KEY);
}


/**
 * Sets the collapsed state of a plugin section within the plugins sidebar.
 * @param {HTMLElement} headerElement - The header element of the plugin section.
 * @param {HTMLElement} contentElement - The content element of the plugin section.
 * @param {boolean} isCollapsed - The desired state (true for collapsed).
 * @param {string} localStorageKey - The key to use for localStorage.
 */
export function setPluginSectionCollapsed(headerElement, contentElement, isCollapsed, localStorageKey) {
     if (!headerElement || !contentElement) return;

     const toggleIcon = headerElement.querySelector('.toggle-icon');

     if (isCollapsed) {
         contentElement.classList.add('hidden');
         headerElement.classList.add('collapsed');
         if (toggleIcon) toggleIcon.classList.replace('fa-chevron-down', 'fa-chevron-right');
     } else {
         contentElement.classList.remove('hidden');
         headerElement.classList.remove('collapsed');
         if (toggleIcon) toggleIcon.classList.replace('fa-chevron-right', 'fa-chevron-down');
     }
     localStorage.setItem(localStorageKey, isCollapsed);
}


/**
 * Updates the microphone button icons and styles based on recording state and active tab.
 */
export function renderMicButtonState() {
    const { micButton, micButtonNotes } = elements;
    const isRecording = state.isRecording;
    const activeTab = state.currentTab;
    const targetButton = activeTab === 'chat' ? micButton : (activeTab === 'notes' ? micButtonNotes : null);
    const otherButton = activeTab === 'chat' ? micButtonNotes : (activeTab === 'notes' ? micButton : null);

    if (otherButton) {
        otherButton.disabled = true;
        const otherIcon = otherButton.querySelector('i');
        if (otherIcon) {
             otherIcon.classList.remove('fa-stop', 'recording');
             otherIcon.classList.add('fa-microphone');
        }
    }

    if (!targetButton) return;

    const iconWrapper = targetButton.querySelector('.mic-icon-wrapper');
    const progressRing = targetButton.querySelector('.mic-progress-ring');

    if (isRecording) {
        targetButton.title = "Stop Recording";
        targetButton.classList.add('recording');
        const iconElement = iconWrapper?.querySelector('i');
        if (iconElement) {
            iconElement.classList.remove('fa-microphone');
            iconElement.classList.add('fa-stop');
            if (iconWrapper) iconWrapper.style.display = 'inline-block';
        }

    } else {
        targetButton.title = activeTab === 'chat' ? "Record Voice" : "Record Voice into Note";
        targetButton.classList.remove('recording');
         const iconElement = iconWrapper?.querySelector('i');
         if (iconElement) {
            iconElement.classList.remove('fa-stop');
            iconElement.classList.add('fa-microphone');
            if (iconWrapper) iconWrapper.style.display = 'inline-block';
         }
    }

    targetButton.disabled = state.isLoading;

    if (!isRecording && !state.isSocketConnected && !targetButton.disabled) {
        targetButton.title += " (Service Disconnected)";
        targetButton.classList.add('disconnected-cue');
    } else if (!isRecording) {
        targetButton.classList.remove('disconnected-cue');
    }
}


/**
 * Updates the UI based on which plugins are enabled/disabled (reads from state).
 */
export function updatePluginUI() {

    if (!elements.filePluginSection || !elements.fileUploadSessionLabel || !elements.selectedFilesContainer ||
        !elements.calendarPluginSection || !elements.calendarToggle || !elements.webSearchToggleLabel ||
        !elements.uploadedFilesList || !elements.manageFilesList || !elements.calendarStatus ||
        !elements.viewCalendarButton || !elements.webSearchToggle || !elements.historyPluginSection || !elements.noteHistoryList ||
        !elements.pluginsSidebar || !elements.pluginsToggleTab) {
        console.warn("Missing core plugin elements for updatePluginUI.");
        return;
    }
    const activeTab = state.currentTab;
    const showFilesPlugin = activeTab === 'chat'; // Files plugin only for chat
    if (elements.filePluginSection) elements.filePluginSection.classList.toggle('hidden', !showFilesPlugin);
    const showCalendarPlugin = activeTab === 'chat'; // Calendar plugin only for chat
    if (elements.calendarPluginSection) elements.calendarPluginSection.classList.toggle('hidden', !showCalendarPlugin);
    const showHistoryPlugin = activeTab === 'notes'; // History plugin only for notes
    if (elements.historyPluginSection) elements.historyPluginSection.classList.toggle('hidden', !showHistoryPlugin);

    if (showFilesPlugin) {
        renderUploadedFiles();
    } else {
         if (elements.uploadedFilesList) elements.uploadedFilesList.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-sm p-1">Switch to Chat tab to use Files plugin.</p>`;
         if (elements.manageFilesList) elements.manageFilesList.innerHTML = `<p class="text-gray-500 text-xs p-1">Switch to Chat tab to use Files plugin.</p>`;
         renderAttachedAndSessionFiles();
         updateAttachButtonState();
    }
     if (showCalendarPlugin) {
        updateCalendarStatus();
     } else {
         if (elements.calendarStatus) elements.calendarStatus.textContent = `Status: Switch to Chat tab to use Calendar plugin.`;
         if (elements.viewCalendarButton) elements.viewCalendarButton.classList.add('hidden');
         if (elements.calendarToggle) elements.calendarToggle.checked = false;
     }
    if (showHistoryPlugin) {
        renderNoteHistory();
        updateTocVisibility();
    } else {
        if (elements.noteHistoryList) elements.noteHistoryList.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">Switch to Notes tab to view history.</p>`;
        updateTocVisibility();
    }
    const anyPluginSectionVisible = showFilesPlugin || showCalendarPlugin || showHistoryPlugin;
    if (elements.pluginsSidebar) elements.pluginsSidebar.classList.toggle('hidden', !anyPluginSectionVisible);
    // Ensure the toggle tab is always potentially visible (not hidden by this JS logic)
    // Its actual display (collapsed or not) is handled by its 'collapsed' class and CSS.
    if (elements.pluginsToggleTab) {
        elements.pluginsToggleTab.classList.remove('hidden');
    }
    renderChatInputArea();
}

/**
 * Updates the calendar status text and view button visibility (reads from state).
 */
export function updateCalendarStatus() {
    const { calendarStatus, viewCalendarButton, calendarToggle } = elements;
    if (!calendarStatus || !viewCalendarButton || !calendarToggle) {
        return;
    }

    const context = state.calendarContext;
    const isActive = state.isCalendarContextActive;
    calendarToggle.disabled = false;

    if (context) {
        const eventCount = context.events ? context.events.length : 0;
        calendarStatus.textContent = `Status: Loaded ${eventCount} events (last updated: ${new Date(context.timestamp).toLocaleTimeString()})`;
        viewCalendarButton.classList.remove('hidden');
        calendarToggle.checked = isActive;
    } else {
        calendarStatus.textContent = "Status: Not loaded";
        viewCalendarButton.classList.add('hidden');
        calendarToggle.checked = false;
    }
}

/**
 * Renders the chat input area elements based on plugin states.
 */
export function renderChatInputArea() {
    const {
        fileUploadSessionLabel, webSearchToggleLabel, webSearchToggle, calendarToggle,
        deepResearchToggleLabel, deepResearchToggle, improvePromptToggleLabel, improvePromptToggle,
        inputArea // Added inputArea to hide the whole thing
    } = elements;

    const isChatTab = state.currentTab === 'chat';

    if (inputArea) inputArea.classList.toggle('hidden', !isChatTab);

    if (!isChatTab) return; // Don't update individual controls if not on chat tab

    // These elements are inside inputArea, so their visibility is already handled.
    // Keeping these checks for logical completeness or if layout changes.
    if (fileUploadSessionLabel) fileUploadSessionLabel.classList.toggle('hidden', !isChatTab);
    if (calendarToggle) calendarToggle.checked = state.isCalendarContextActive;
    if (webSearchToggleLabel) webSearchToggleLabel.classList.toggle('hidden', !isChatTab);
    if (webSearchToggle) webSearchToggle.checked = state.isWebSearchEnabled;
    if (deepResearchToggleLabel) deepResearchToggleLabel.classList.toggle('hidden', !isChatTab);
    if (deepResearchToggle) deepResearchToggle.checked = state.isDeepResearchEnabled;
    if (improvePromptToggleLabel) improvePromptToggleLabel.classList.toggle('hidden', !isChatTab);
    if (improvePromptToggle) improvePromptToggle.checked = state.isImprovePromptEnabled;
}


/**
 * Switches between the Chat, Notes, and TODO tabs (updates UI visibility).
 * @param {'chat' | 'notes' | 'todo'} tab - The desired tab.
 */
export function switchTab(tab) {
    const {
        chatNavButton, notesNavButton, // Sidebar nav buttons (potentially legacy for direct activation)
        chatTabButton, notesTabButton, todoTabButton, // Main sidebar tab buttons
        chatSection, notesSection, todoSection, // Main content sections
        filesTabContent, searchTabContent, // Other main content sections (still exist but not in main nav)
        chatSidebarContent, notesSidebarContent, modelSelectorContainer,
        notesModeElements, inputArea
    } = elements;

    // Check for essential elements for basic tab switching
    if (!elements.chatTabButton || !elements.notesTabButton || !elements.todoTabButton ||
        !chatSection || !notesSection || !todoSection || !filesTabContent || !searchTabContent) {
        console.error("Missing essential elements for tab switching in main content or sidebar navigation.", {
            chatTabButton: elements.chatTabButton, notesTabButton: elements.notesTabButton, todoTabButton: elements.todoTabButton,
            chatSection, notesSection, todoSection, filesTabContent, searchTabContent
        });
        return;
    }

    // Main navigation tab buttons (now in the sidebar)
    const mainNavTabs = [
        { button: elements.chatTabButton, name: 'chat', content: elements.chatSection },
        { button: elements.notesTabButton, name: 'notes', content: elements.notesSection },
        { button: elements.todoTabButton, name: 'todo', content: elements.todoSection }
        // Removed Files and Search from main navigation
        // { button: elements.filesTabButton, name: 'files', content: elements.filesTabContent },
        // { button: elements.searchTabButton, name: 'search', content: elements.searchTabContent }
    ];

    mainNavTabs.forEach(navTab => {
        if (navTab.button) {
            // Use the 'active' class for styling the selected tab button in the sidebar group
            navTab.button.classList.toggle('active', navTab.name === tab);
        }
        // Toggle content visibility
        if (navTab.content) {
            navTab.content.classList.toggle('hidden', navTab.name !== tab);
        } else {
            console.warn(`Content area for tab '${navTab.name}' not found in elements object.`);
        }
    });
    
    // The old chatNavButton and notesNavButton are effectively replaced by the new tab group.
    // Their specific 'active' class toggling for primary navigation is no longer needed here,
    // as the loop above handles the 'active' state for the new main tab buttons.
    // if (elements.chatNavButton) elements.chatNavButton.classList.toggle('active', tab === 'chat'); // This might be redundant now
    // if (elements.notesNavButton) elements.notesNavButton.classList.toggle('active', tab === 'notes'); // This might be redundant now

    // Toggle sidebar content visibility (e.g., chat list vs notes list)
    if (elements.chatSidebarContent) elements.chatSidebarContent.classList.toggle('hidden', tab !== 'chat');
    if (elements.notesSidebarContent) elements.notesSidebarContent.classList.toggle('hidden', tab !== 'notes');
    // TODO: Add a sidebar section for TODOs if needed in the future

    // Toggle header elements specific to certain tabs
    if (elements.modelSelectorContainer) elements.modelSelectorContainer.classList.toggle('hidden', tab !== 'chat');
    if (elements.notesModeElements) elements.notesModeElements.classList.toggle('hidden', tab !== 'notes');
    if (elements.inputArea) elements.inputArea.classList.toggle('hidden', tab !== 'chat');


    renderCurrentChatDetails(); // Safe to call, checks elements internally
    renderCurrentNoteDetails(); // Safe to call, checks elements internally

    if (tab === 'chat') {
        renderChatHistory();
    } else if (tab === 'notes') {
        renderNoteContent();
        setNoteMode(state.currentNoteMode);
    } else if (tab === 'todo') {
        renderTodoList(); 
        resetTodoForm();  
        // api.loadTodoItems() is called by eventListeners.js when tab is switched.
    }
    updatePluginUI(); 
    updateNotesCleanupButtonState();
    updateChatCleanupButtonState();
}

/**
 * Sets the display mode for the notes section (edit or view) based on state.
 * @param {'edit' | 'view'} mode - The desired mode.
 */
export function setNoteMode(mode) {
    const { notesTextarea, notesPreview, editNoteButton, viewNoteButton, notesMicButtonGroup } = elements;
    if (!notesTextarea || !notesPreview || !editNoteButton || !viewNoteButton || !notesMicButtonGroup) {
        console.error("Missing elements for note mode switching.");
        return;
    }
    console.log(`[DEBUG] setNoteMode called with mode: '${mode}'. notesMicButtonGroup exists: ${!!notesMicButtonGroup}`);
    if (state.currentNoteMode === 'edit') {
        notesTextarea.classList.remove('hidden');
        notesPreview.classList.add('hidden');
        console.log("[DEBUG] setNoteMode: Setting to EDIT mode. Removing 'hidden' from notesMicButtonGroup.");
        editNoteButton.classList.add('active');
        viewNoteButton.classList.remove('active');
        notesMicButtonGroup.classList.remove('hidden');
        
        _currentNoteH1Sections = [];
        notesPreview.innerHTML = '';
        notesPreview.classList.remove('prose', 'prose-sm', 'max-w-none');
        autoResizeTextarea(notesTextarea);
        generateAndRenderToc(state.noteContent || '');
    } else {
        notesTextarea.classList.add('hidden');
        notesPreview.classList.remove('hidden');
        console.log("[DEBUG] setNoteMode: Setting to VIEW mode. Adding 'hidden' to notesMicButtonGroup.");
        notesMicButtonGroup.classList.add('hidden');
        editNoteButton.classList.remove('active');
        viewNoteButton.classList.add('active');
        updateNotesPreview();
    }
}


function _parseNoteIntoH1Sections(markdown) {
    if (!markdown || markdown.trim() === '') {
        return [{ title: "Note", rawMarkdownContent: markdown, isOnlySection: true, isFallback: true }];
    }

    const tokens = marked.lexer(markdown);
    const sections = [];
    let currentSectionTokens = [];
    let currentH1Title = null;

    const firstH1TokenIndex = tokens.findIndex(token => token.type === 'heading' && token.depth === 1);

    if (firstH1TokenIndex === -1) {
        return [{ title: "Note", rawMarkdownContent: markdown, isOnlySection: true, isFallback: true }];
    }

    if (firstH1TokenIndex > 0) {
        const preH1ContentTokens = tokens.slice(0, firstH1TokenIndex);
        if (preH1ContentTokens.some(t => t.raw.trim() !== '')) {
             sections.push({
                title: "Overview",
                rawMarkdownContent: preH1ContentTokens.map(t => t.raw).join(''),
                isPreH1Content: true
            });
        }
    }
    const processTokens = tokens.slice(firstH1TokenIndex);

    processTokens.forEach(token => {
        if (token.type === 'heading' && token.depth === 1) {
            if (currentSectionTokens.length > 0 && currentH1Title) {
                sections.push({
                    title: currentH1Title,
                    rawMarkdownContent: currentSectionTokens.map(t => t.raw).join('')
                });
            }
            currentH1Title = token.text;
            currentSectionTokens = [token];
        } else if (currentH1Title) {
            currentSectionTokens.push(token);
        }
    });
    if (currentSectionTokens.length > 0 && currentH1Title) {
        sections.push({
            title: currentH1Title,
            rawMarkdownContent: currentSectionTokens.map(t => t.raw).join('')
        });
    }
    
    if (sections.length === 0 && markdown.trim().length > 0) {
        return [{ title: "Note", rawMarkdownContent: markdown, isOnlySection: true, isFallback: true }];
    }
    
    sections.forEach(s => s.isFallback = false);

    if (sections.length === 1 && !sections[0].isPreH1Content) {
        sections[0].isOnlySection = true; 
    } else if (sections.length > 0) {
        sections.forEach(s => s.isOnlySection = false);
    }

    return sections;
}

export function updateNotesPreview() {
    const { notesTextarea, notesPreview } = elements;
    if (!notesTextarea || !notesPreview) return;
    let showTabs = false;
    _currentNoteH1Sections = _parseNoteIntoH1Sections(state.noteContent || '');

    if (state.currentNoteMode === 'view') {
        notesPreview.innerHTML = '';
        notesPreview.classList.remove('prose', 'prose-sm', 'max-w-none');
        showTabs = _currentNoteH1Sections.length > 0 && !(_currentNoteH1Sections.length === 1 && _currentNoteH1Sections[0].isFallback === true);

        if (showTabs) {
            const tabsContainer = document.createElement('div');
            tabsContainer.id = 'note-h1-tabs-container';
            tabsContainer.className = 'note-h1-tabs';
            _currentNoteH1Sections.forEach((section, index) => {
                const tabButton = document.createElement('button');
                tabButton.className = 'note-h1-tab';
                tabButton.textContent = section.title || `Section ${index + 1}`;
                tabButton.dataset.sectionIndex = index;
                if (index === state.currentNoteActiveH1SectionIndex) tabButton.classList.add('active');
                tabButton.addEventListener('click', () => state.setCurrentNoteActiveH1SectionIndex(index));
                tabsContainer.appendChild(tabButton);
            });
            notesPreview.appendChild(tabsContainer);
            const contentContainer = document.createElement('div');
            contentContainer.id = 'note-h1-content-container';
            contentContainer.className = 'note-h1-content prose prose-sm max-w-none';
            notesPreview.appendChild(contentContainer);
            _renderActiveH1SectionUI(); // This will call initializeListJsForTables internally for the H1 section
        } else {
            // This is for when there are no H1 tabs, content directly in notesPreview
            if (typeof marked !== 'undefined') {
                const rawHtml = marked.parse(state.noteContent || '', { renderer: markedRenderer, ...config.markedOptions });
                // notesPreview.innerHTML = rawHtml; // Original line
                const tempDiv = document.createElement('div'); // Use a temporary div for processing
                tempDiv.innerHTML = rawHtml;
                // Assuming makeHeadingsCollapsible should also run here if headings are present without H1 tabs
                const processedFragment = makeHeadingsCollapsible(tempDiv.innerHTML);
                notesPreview.appendChild(processedFragment);

                notesPreview.classList.add('prose', 'prose-sm', 'max-w-none');

                // Call the helper function for tables in notesPreview
                initializeListJsForTables(notesPreview, `note-${state.currentNoteId || 'current'}`);

                waitForGraphViewerAndProcess();
                generateAndRenderToc(state.noteContent || '');
            } else {
                notesPreview.textContent = state.noteContent || '';
            }
        }
    }
    if (state.currentNoteMode === 'edit' || (state.currentNoteMode === 'view' && !showTabs)) {
        const debouncedUpdateToc = debounce(() => {
            if (state.currentTab === 'notes') generateAndRenderToc(state.noteContent || '');
        }, 300);
        debouncedUpdateToc();
    }
}

function _renderActiveH1SectionUI() {
    const showTabs = _currentNoteH1Sections.length > 0 && !(_currentNoteH1Sections.length === 1 && _currentNoteH1Sections[0].isFallback === true);
    if (state.currentNoteMode !== 'view' || !showTabs) return;

    const activeIndex = state.currentNoteActiveH1SectionIndex;
    const section = _currentNoteH1Sections[activeIndex];
    if (!section) return;

    const contentContainer = document.getElementById('note-h1-content-container');
    if (!contentContainer) return;
    contentContainer.innerHTML = '';

    if (typeof marked !== 'undefined') {
        const rawHtml = marked.parse(section.rawMarkdownContent || '', { renderer: markedRenderer, ...config.markedOptions });
        const collapsibleFragment = makeHeadingsCollapsible(rawHtml);
        contentContainer.appendChild(collapsibleFragment);

        // Initialize List.js for tables within the active H1 section's content
        const activeIndex = state.currentNoteActiveH1SectionIndex; // Get current index for unique ID
        initializeListJsForTables(contentContainer, `note-${state.currentNoteId || 'current'}-h1section-${activeIndex}`);

        waitForGraphViewerAndProcess();
        generateAndRenderToc(section.rawMarkdownContent || '');
    } else {
        contentContainer.textContent = section.rawMarkdownContent || '';
    }

    const tabsContainer = document.getElementById('note-h1-tabs-container');
    if (tabsContainer) {
        tabsContainer.querySelectorAll('.note-h1-tab').forEach(tab => {
            tab.classList.remove('active');
            if (parseInt(tab.dataset.sectionIndex) === activeIndex) tab.classList.add('active');
        });
    }
}

export function renderNoteHistory() {
    const { noteHistoryList } = elements;
    if (!noteHistoryList) return;
    noteHistoryList.innerHTML = '';
    const history = state.noteHistory;
    const currentNoteId = state.currentNoteId;

    if (currentNoteId === null) {
         noteHistoryList.innerHTML = '<p class="text-rz-sidebar-text opacity-75 text-xs p-1">Select a note to view history.</p>';
         return;
    }
    if (!history || history.length === 0) {
        noteHistoryList.innerHTML = '<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No save history for this note.</p>';
        return;
    }

    history.forEach((entry, index) => {
        const listItem = document.createElement('div');
        listItem.classList.add('list-item', 'history-list-item', 'p-2', 'border-rz-sidebar-border', 'cursor-pointer', 'hover:bg-rz-sidebar-hover');
        listItem.dataset.historyId = entry.id;
        const headerDiv = document.createElement('div');
        headerDiv.classList.add('flex', 'justify-between', 'items-center');
        const nameSpan = document.createElement('span');
        nameSpan.classList.add('text-rz-sidebar-text', 'text-sm', 'truncate', 'flex-grow');
        nameSpan.textContent = entry.name || state.currentNoteName || 'Untitled';
        headerDiv.appendChild(nameSpan);
        const timestampDiv = document.createElement('div');
        timestampDiv.classList.add('text-rz-sidebar-text', 'opacity-75', 'text-xs', 'ml-2', 'flex-shrink-0');
        timestampDiv.textContent = new Date(entry.saved_at).toLocaleString();
        listItem.appendChild(headerDiv);
        listItem.appendChild(timestampDiv);
        const diffDiv = document.createElement('div');
        diffDiv.classList.add('text-xs', 'mt-1', 'text-rz-sidebar-text', 'opacity-80', 'note-diff-summary', 'line-clamp-2');
        const isInitialVersion = index === history.length - 1;
        let summaryText = "";
        let summaryTitle = "";
        if (isInitialVersion) {
            summaryText = "Initial version";
            summaryTitle = "Initial version of the note.";
        } else if (entry.note_diff) {
            summaryText = entry.note_diff;
            summaryTitle = entry.note_diff;
            if (summaryText === "[Metadata change only]") {
                 summaryText = "Name/Metadata changed";
                 summaryTitle = "Only the note name or other metadata changed in this version.";
            } else if (summaryText.startsWith("[AI summary generation failed]") || summaryText.startsWith("[Summary generation error]")) {
                 summaryText = "Summary unavailable";
                 summaryTitle = "Could not generate summary for this version.";
                 diffDiv.classList.add('text-red-400');
            }
        } else {
            summaryText = "Summary pending...";
            summaryTitle = "Summary is being generated or was not created.";
            diffDiv.classList.add('opacity-60');
        }
        diffDiv.textContent = summaryText;
        diffDiv.title = summaryTitle;
        listItem.appendChild(diffDiv);
        noteHistoryList.appendChild(listItem);
    });
}

export function openModal(modalElement) {
    if (modalElement) {
        modalElement.classList.add('show');
        if (elements.bodyElement) elements.bodyElement.classList.add('modal-open');
    }
}

// NOTE: The old closeModal function is replaced by the more specific hideModal function above.
//       Any calls to closeModal should be updated to hideModal.


/**
 * Renders the content of the file preview modal based on state.
 */
function renderFileContentModal() {
    console.log('[DEBUG] renderFileContentModal called.'); // LOG: Function entry
    const { fileContentModalFilename, fileContentModalContent, fileContentModal } = elements;

    // --- Check if DOM elements exist ---
    if (!fileContentModal) {
        console.error('[DEBUG] renderFileContentModal: fileContentModal element not found.');
        return;
    }
    if (!fileContentModalFilename) {
        console.error('[DEBUG] renderFileContentModal: fileContentModalFilename element not found.');
        return;
    }
    if (!fileContentModalContent) {
        console.error('[DEBUG] renderFileContentModal: fileContentModalContent element not found.');
        return;
    }
    // -----------------------------------

    // --- Get state values ---
    const filename = state.currentViewingFilename;
    let fileContent = state.currentViewingFileContent;
    const mimetype = state.currentViewingFileMimetype;
    const isOriginallyBase64 = state.currentViewingFileIsBase64;
    // ------------------------

    // --- Log state values ---
    console.log(`[DEBUG] renderFileContentModal states:
        Filename: ${filename} (type: ${typeof filename})
        Mimetype: ${mimetype} (type: ${typeof mimetype})
        IsOriginallyBase64: ${isOriginallyBase64} (type: ${typeof isOriginallyBase64})
        FileContent (first 100 chars): ${typeof fileContent === 'string' ? fileContent.substring(0, 100) : fileContent} (type: ${typeof fileContent})`);
    // ------------------------

    // --- Handle case where no file is selected or content is missing ---
    if (filename === null || fileContent === null || mimetype === null) {
        fileContentModalFilename.textContent = 'File Preview';
        fileContentModalContent.innerHTML = '<p class="text-gray-500 dark:text-gray-400">No file selected or content not available.</p>';
        console.log('[DEBUG] renderFileContentModal: Rendered "No file selected..."');
        return;
    }
    // -----------------------------------------------------------------

    // --- Set filename and clear previous content ---
    fileContentModalFilename.textContent = escapeHtml(filename);
    console.log(`[DEBUG] renderFileContentModal: Set modal filename to: ${filename}`);
    const initialModalContentHTML = fileContentModalContent.innerHTML; // Log initial content for comparison
    fileContentModalContent.innerHTML = ''; // Clear previous content
    console.log(`[DEBUG] renderFileContentModal: Cleared modal content. Was: "${initialModalContentHTML.substring(0,100)}...", Now: "${fileContentModalContent.innerHTML}"`);
    // ---------------------------------------------

    // --- Determine how to display content ---
    const isTextDisplayable = mimetype.startsWith('text/') ||
        [
            'application/json', 'application/xml', 'application/javascript',
            'application/x-python-code', 'application/x-sh', 'application/csv',
            'application/rtf', 'application/x-tex', 'application/x-latex',
            'application/vnd.oasis.opendocument.text', // ODT
            'application/msword', // .doc (might not render well)
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document' // .docx
        ].includes(mimetype) ||
        /\.(txt|py|js|jsx|ts|tsx|html|htm|css|scss|less|md|json|csv|xml|log|yaml|yml|ini|cfg|sh|bash|zsh|ps1|bat|java|c|cpp|h|hpp|cs|go|rb|php|swift|kt|kts|dart|rs|lua|pl|sql|r|vbs|conf|rtf|tex|odt|doc|docx)$/i.test(filename);
    console.log(`[DEBUG] renderFileContentModal: isTextDisplayable = ${isTextDisplayable} (mimetype: ${mimetype}, filename: ${filename})`);

    let contentForTextDisplay = "";
    let srcForEmbedOrImg = "";

    // Process content based on its type (Data URL, raw base64, or plain text)
    if (typeof fileContent === 'string' && fileContent.startsWith('data:')) {
        console.log('[DEBUG] renderFileContentModal: Handling content as Data URL.');
        srcForEmbedOrImg = fileContent;
        if (isTextDisplayable) {
            try {
                const base64Data = fileContent.substring(fileContent.indexOf(',') + 1);
                contentForTextDisplay = atob(base64Data);
                console.log('[DEBUG] renderFileContentModal: Decoded text from Data URL.');
            } catch (e) {
                console.error("[DEBUG] renderFileContentModal: Error decoding base64 text from data URL:", e);
                contentForTextDisplay = "Error decoding content from data URL.";
            }
        }
    } else if (isOriginallyBase64) {
        console.log('[DEBUG] renderFileContentModal: Handling content as raw base64 string.');
        if (isTextDisplayable) {
            try {
                contentForTextDisplay = atob(fileContent);
                console.log('[DEBUG] renderFileContentModal: Decoded text from raw base64 string.');
            } catch (e) {
                console.error("[DEBUG] renderFileContentModal: Error decoding base64 text content:", e);
                contentForTextDisplay = "Error decoding base64 content.";
            }
        } else {
            srcForEmbedOrImg = `data:${mimetype};base64,${fileContent}`;
            console.log(`[DEBUG] renderFileContentModal: Created Data URL for binary content: data:${mimetype};base64,...`);
        }
    } else {
        console.log('[DEBUG] renderFileContentModal: Handling content as plain text string.');
        contentForTextDisplay = fileContent;
    }
    // ----------------------------------------

    // --- Render content based on mimetype ---
    if (mimetype.startsWith('image/')) {
        console.log('[DEBUG] renderFileContentModal: Rendering as image.');
        const img = document.createElement('img');
        img.src = srcForEmbedOrImg;
        img.alt = escapeHtml(filename);
        img.className = 'max-w-full max-h-[70vh] object-contain mx-auto';
        fileContentModalContent.appendChild(img);
    } else if (mimetype === 'application/pdf' && srcForEmbedOrImg) {
        console.log('[DEBUG] renderFileContentModal: Rendering as PDF embed.');
        const embed = document.createElement('embed');
        embed.src = srcForEmbedOrImg;
        embed.type = 'application/pdf';
        embed.className = 'w-full h-[75vh]';
        fileContentModalContent.appendChild(embed);
    } else if (isTextDisplayable) {
        console.log('[DEBUG] renderFileContentModal: Rendering as preformatted text.');
        const pre = document.createElement('pre');
        pre.className = 'whitespace-pre-wrap break-all p-2 bg-gray-100 dark:bg-gray-700 dark:text-gray-200 rounded text-sm overflow-auto max-h-[75vh]';
        pre.textContent = contentForTextDisplay;
        fileContentModalContent.appendChild(pre);
    } else {
        console.log('[DEBUG] renderFileContentModal: Rendering "Preview not available" fallback.');
        const p = document.createElement('p');
        p.className = 'text-gray-600 dark:text-gray-400';
        p.textContent = `Preview not available for this file type (${escapeHtml(mimetype)}).`;
        
        let downloadHref = null;
        if (srcForEmbedOrImg) {
            downloadHref = srcForEmbedOrImg;
        } else if (isOriginallyBase64 && !isTextDisplayable) { 
            downloadHref = `data:${mimetype};base64,${fileContent}`;
        }

        if (downloadHref) {
            const downloadLink = document.createElement('a');
            downloadLink.href = downloadHref;
            downloadLink.download = filename;
            downloadLink.textContent = `Download ${escapeHtml(filename)}`;
            downloadLink.className = 'text-blue-500 hover:underline ml-2';
            p.appendChild(document.createElement('br'));
            p.appendChild(downloadLink);
            console.log(`[DEBUG] renderFileContentModal: Added download link for ${filename}.`);
        }
        fileContentModalContent.appendChild(p);
    }
    // --------------------------------------
    console.log(`[DEBUG] renderFileContentModal: Final modal content HTML (first 200 chars): "${fileContentModalContent.innerHTML.substring(0,200)}"`);
}


export function handleStateChange_isLoading() {
    updateLoadingState();
    renderNoteContent();
    renderMicButtonState();
    updateNotesCleanupButtonState();
    updateChatCleanupButtonState();
    updateChatListProcessingIndicator();
}

export function handleStateChange_statusMessage() {
    renderStatus();
}
 
export function handleStateChange_savedChats() {
    renderSavedChats();
    updateChatListProcessingIndicator();
}
 
export function handleStateChange_currentChat() {
    renderCurrentChatDetails();
    updateActiveChatListItem();
}

export function handleStateChange_chatHistory() {
    renderChatHistory();
}

export function handleStateChange_isRecording() {
    renderMicButtonState();
}

export function handleStateChange_isSocketConnected() {
    renderMicButtonState();
}

export function handleStateChange_streamingTranscript() {
    renderStreamingTranscript();
}

export function handleStateChange_savedNotes() {
    renderSavedNotes();
    // If note search is active, we might need to re-render search results or clear them
    if (state.isNoteSearchActive) {
        // This will be handled by renderNoteSearchResults in a later step
        console.log("Saved notes changed while search is active. Search results might need update.");
    }
}

export function handleStateChange_currentNote() {
    renderCurrentNoteDetails();
    updateActiveNoteListItem();
    renderNoteContent();
}

export function handleStateChange_noteContent() {
    renderNoteContent();
    if (state.currentTab === 'notes' && state.currentNoteMode === 'view') {
        updateNotesPreview();
    }
}

export function handleStateChange_uploadedFiles() {
    renderUploadedFiles();
}

export function handleStateChange_sidebarSelectedFiles() {
    updateSelectedFileListItemStyling();
    updateAttachButtonState();
}

export function handleStateChange_attachedFiles() {
    renderAttachedAndSessionFiles();
}

export function handleStateChange_sessionFile() {
    renderAttachedAndSessionFiles();
}

export function handleStateChange_currentEditingFileId() {
    renderSummaryModalContent();
}

export function handleStateChange_summaryContent() {
    renderSummaryModalContent();
}

export function handleStateChange_isFileContentModalOpen() {
    if (state.isFileContentModalOpen) {
        // Content rendering is triggered by other state changes (currentViewingFile...)
        // So, just ensure modal is shown.
        showModal(elements.fileContentModal);
    } else {
        hideModal(elements.fileContentModal);
    }
}

export function handleStateChange_currentViewingFileId() {
    // This state change primarily triggers renderFileContentModal
    renderFileContentModal();
}

export function handleStateChange_currentViewingFilename() {
    // This state change primarily triggers renderFileContentModal
    renderFileContentModal();
}

export function handleStateChange_currentViewingFileContent() {
    // This state change primarily triggers renderFileContentModal
    renderFileContentModal();
}

export function handleStateChange_currentViewingFileMimetype() {
    // This state change primarily triggers renderFileContentModal
    renderFileContentModal();
}

export function handleStateChange_currentViewingFileIsBase64() {
    // This state change primarily triggers renderFileContentModal
    renderFileContentModal();
}


export function handleStateChange_calendarContext() {
    updateCalendarStatus();
}

export function handleStateChange_isCalendarContextActive() {
    updateCalendarStatus();
    renderChatInputArea();
}

export function handleStateChange_isWebSearchEnabled() {
    renderChatInputArea();
}

export function handleStateChange_currentTab() {
    switchTab(state.currentTab);
}

export function handleStateChange_processingChatId() {
    updateLoadingState();
    updateChatListProcessingIndicator();
}

export function handleStateChange_currentNoteMode() {
    setNoteMode(state.currentNoteMode);
}

export function handleStateChange_isDeepResearchEnabled() {
    renderChatInputArea();
}

export function handleStateChange_isImprovePromptEnabled() {
    renderChatInputArea();
}

export function handleStateChange_noteHistory() {
    renderNoteHistory();
}

export function updateNotesCleanupButtonState() {
    if (!elements.notesTextarea || !elements.cleanupTranscriptButtonNotes) return;
    const hasSelection = elements.notesTextarea.selectionStart !== elements.notesTextarea.selectionEnd;
    elements.cleanupTranscriptButtonNotes.disabled = !(state.currentTab === 'notes' && !state.isLoading && hasSelection);
}

export function updateChatCleanupButtonState() {
    if (!elements.messageInput || !elements.cleanupTranscriptButton) return;
    const hasSelection = elements.messageInput.selectionStart !== elements.messageInput.selectionEnd;
    elements.cleanupTranscriptButton.disabled = !(state.currentTab === 'chat' && !state.isLoading && hasSelection);
}

export function renderStreamingTranscript() {
    const finalized = state.finalizedTranscript;
    const interim = state.currentInterimTranscript;
    const fullTranscript = finalized ? `${finalized} ${interim}` : interim;
    const context = state.recordingContext;
    const targetElement = getInputElementForContext(context);

    if (targetElement) {
        if (context === 'notes' && originalNoteTextBeforeRecording !== null) {
            targetElement.value = originalNoteTextBeforeRecording + (originalNoteTextBeforeRecording ? "\n\n" : "") + fullTranscript.trim();
        } else {
            targetElement.value = fullTranscript.trim();
        }
        autoResizeTextarea(targetElement);
    }
}

export function handleStateChange_isSidebarCollapsed() {
    const isCollapsed = state.isSidebarCollapsed;
    const sidebarElement = document.getElementById('sidebar');
    const toggleButton = document.getElementById('sidebar-toggle-tab');
    if (!sidebarElement || !toggleButton) return;
    sidebarElement.classList.toggle('collapsed', isCollapsed);
    toggleButton.classList.toggle('collapsed', isCollapsed);
    const icon = toggleButton.querySelector('i');
    if (icon) {
        icon.classList.toggle('fa-chevron-left', !isCollapsed);
        icon.classList.toggle('fa-chevron-right', isCollapsed);
    }
}

export function handleStateChange_isPluginsCollapsed() {
    const isCollapsed = state.isPluginsCollapsed;
    const sidebarElement = document.getElementById('plugins-sidebar');
    const toggleButton = document.getElementById('plugins-toggle-tab');
    if (!sidebarElement || !toggleButton) return;
    sidebarElement.classList.toggle('collapsed', isCollapsed);
    toggleButton.classList.toggle('collapsed', isCollapsed);
    const icon = toggleButton.querySelector('i');
    if (icon) {
        icon.classList.toggle('fa-chevron-right', !isCollapsed);
        icon.classList.toggle('fa-chevron-left', isCollapsed);
    }
}

function generateTocData(markdown) {
    if (!markdown) return [];
    const toc = [];
    const tokens = marked.lexer(markdown);
    tokens.forEach(token => {
        if (token.type === 'heading') {
            const level = token.depth;
            const text = token.text || `heading-${Date.now()}`;
            const slug = text.toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
            const targetId = `toc-heading-level-${level}-${slug}`;
            toc.push({ level: level, text: token.text, targetId: targetId });
        }
    });
    return toc;
}

function renderTableOfContents(tocData) {
    const { notesTocList } = elements;
    if (!notesTocList) return;
    notesTocList.innerHTML = '';
    if (!tocData || tocData.length === 0) {
        notesTocList.innerHTML = '<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No headings found.</p>';
        return;
    }
    tocData.forEach(item => {
        const link = document.createElement('a');
        link.href = `#${item.targetId}`;
        link.classList.add('toc-item', `toc-level-${item.level}`, 'toc-link');
        link.textContent = item.text;
        link.title = `Jump to: ${item.text}`;
        link.dataset.targetId = item.targetId;
        notesTocList.appendChild(link);
    });
}

export function generateAndRenderToc(customMarkdownContent = null) {
    if (state.currentTab === 'notes') {
        const markdownToParse = customMarkdownContent !== null ? customMarkdownContent : (state.noteContent || '');
        const tocData = generateTocData(markdownToParse);
        renderTableOfContents(tocData);
    }
}

export function updateTocVisibility() {
    const { notesTocDrawer } = elements;
    if (!notesTocDrawer) return;
    notesTocDrawer.classList.toggle('hidden', state.currentTab !== 'notes');
}

export function toggleNotesTocDrawer() {
    const { notesTocDrawer } = elements;
    if (!notesTocDrawer) return;
    state.setIsNotesTocCollapsed(!state.isNotesTocCollapsed);
}

export function setNotesTocCollapsedUI(isCollapsed) {
    const { notesTocHeader, notesTocList, notesTocToggle } = elements;
    if (!notesTocHeader || !notesTocList || !notesTocToggle) return;
    const icon = notesTocToggle.querySelector('.toc-toggle-icon');
    notesTocHeader.classList.toggle('collapsed', isCollapsed);
    notesTocList.classList.toggle('collapsed', isCollapsed);
    if (icon) {
        icon.classList.toggle('fa-chevron-up', !isCollapsed);
        icon.classList.toggle('fa-chevron-down', isCollapsed);
    }
    localStorage.setItem(config.NOTES_TOC_COLLAPSED_KEY, isCollapsed);
}

export function handleStateChange_isNotesTocCollapsed() {
    setNotesTocCollapsedUI(state.isNotesTocCollapsed);
}

export function handleStateChange_currentNoteActiveH1SectionIndex() {
    if (state.currentTab === 'notes' && state.currentNoteMode === 'view' && _currentNoteH1Sections.length > 1 && !_currentNoteH1Sections.every(s => s.isOnlySection)) {
        _renderActiveH1SectionUI();
    }
}

export function autoResizeTextarea(textareaElement) {
    if (!textareaElement) return;
    textareaElement.style.height = 'auto';
    textareaElement.style.height = `${textareaElement.scrollHeight}px`;
}

/**
 * Shows or hides the notes search bar based on the state.isNoteSearchActive.
 * This function is now driven by state changes.
 */
export function toggleNotesSearchBarUI() {
    const { notesSearchBarContainer, notesSearchInput } = elements;
    if (!notesSearchBarContainer) {
        console.warn("[UI DEBUG] Notes search bar container (#notes-search-bar-container) not found for UI toggle.");
        return;
    }
    const show = state.isNoteSearchActive; // Read from state
    console.log(`[UI DEBUG] toggleNotesSearchBarUI called. Attempting to ${show ? 'show' : 'hide'} search bar. Element found: ${!!notesSearchBarContainer}. Current classes: ${notesSearchBarContainer.className}`);

    if (show) {
        notesSearchBarContainer.classList.remove('hidden');
        console.log(`[UI DEBUG] notesSearchBarContainer 'hidden' class REMOVED. New classes: ${notesSearchBarContainer.className}. Visible: ${!notesSearchBarContainer.classList.contains('hidden')}`);
        if (notesSearchInput) {
            notesSearchInput.focus();
            console.log("[UI DEBUG] Focused notesSearchInput.");
        }
    } else {
        notesSearchBarContainer.classList.add('hidden');
        console.log(`[UI DEBUG] notesSearchBarContainer 'hidden' class ADDED. New classes: ${notesSearchBarContainer.className}. Visible: ${!notesSearchBarContainer.classList.contains('hidden')}`);
        if (notesSearchInput && document.activeElement === notesSearchInput) {
            notesSearchInput.blur();
            console.log("[UI DEBUG] Blurred notesSearchInput.");
        }
    }
}

// --- Notes Search State Handlers ---
export function handleStateChange_isNoteSearchActive() {
    console.log(`[UI DEBUG] handleStateChange_isNoteSearchActive called. New state: ${state.isNoteSearchActive}`);
    toggleNotesSearchBarUI(); // Update visibility based on state
    if (state.isNoteSearchActive) {
        console.log("[UI DEBUG] Note search is active. Rendering search results or placeholder.");
        renderNoteSearchResults(); // Render results or "type to search"
    } else {
        console.log("[UI DEBUG] Note search is inactive. UI should show normal notes list.");
        renderSavedNotes(); // Re-render the original list of notes
        if (elements.notesSearchInput) {
            elements.notesSearchInput.value = ''; 
            console.log("[UI DEBUG] Cleared notesSearchInput value because search is now inactive.");
        }
    }
}

export function handleStateChange_noteSearchQuery() {
    if (elements.notesSearchInput && elements.notesSearchInput.value !== state.noteSearchQuery) {
        elements.notesSearchInput.value = state.noteSearchQuery;
    }
    console.log(`[UI DEBUG] Note search query state updated to: "${state.noteSearchQuery}"`);
    // If search is active and query changes, re-render (might show "no results" or new results)
    if (state.isNoteSearchActive) {
        renderNoteSearchResults();
    }
}

export function handleStateChange_noteSearchResults() {
    console.log("[UI DEBUG] Note search results state updated:", state.noteSearchResults);
    if (state.isNoteSearchActive) {
        renderNoteSearchResults(); // Render the new results
    }
}


// --- Chat Search State Handlers ---
export function handleStateChange_isChatSearchActive() {
    console.log(`[UI DEBUG] handleStateChange_isChatSearchActive called. New state: ${state.isChatSearchActive}`);
    toggleChatSearchBarUI(); // Update visibility based on state
    if (state.isChatSearchActive) {
        console.log("[UI DEBUG] Chat search is active. Rendering search results or placeholder.");
        renderChatSearchResults(); 
    } else {
        console.log("[UI DEBUG] Chat search is inactive. UI should show normal chat list.");
        renderSavedChats(); // Re-render the original list of chats
        if (elements.chatSearchInput) {
            elements.chatSearchInput.value = ''; 
            console.log("[UI DEBUG] Cleared chatSearchInput value because search is now inactive.");
        }
    }
}

export function handleStateChange_chatSearchQuery() {
    if (elements.chatSearchInput && elements.chatSearchInput.value !== state.chatSearchQuery) {
        elements.chatSearchInput.value = state.chatSearchQuery;
    }
    console.log(`[UI DEBUG] Chat search query state updated to: "${state.chatSearchQuery}"`);
    if (state.isChatSearchActive) {
        renderChatSearchResults();
    }
}

export function handleStateChange_chatSearchResults() {
    console.log("[UI DEBUG] Chat search results state updated:", state.chatSearchResults);
    if (state.isChatSearchActive) {
        renderChatSearchResults(); 
    }
}

export function handleStateChange_targetMessageIdToScroll() {
    // This state change is primarily handled by renderChatHistory when a chat is loaded.
    // No direct UI update here, but log for debugging.
    if (state.targetMessageIdToScroll) {
        console.log(`[UI DEBUG] Target message ID to scroll set to: ${state.targetMessageIdToScroll}. Scrolling will occur on next chat history render.`);
    }
}

/**
 * Shows or hides the chat search bar based on the state.isChatSearchActive.
 */
export function toggleChatSearchBarUI() {
    const { chatSearchBarContainer, chatSearchInput, savedChatsList, chatSearchResultsContainer } = elements;
    if (!chatSearchBarContainer) {
        console.warn("[UI DEBUG] Chat search bar container (#chat-search-bar-container) not found for UI toggle.");
        return;
    }
    const showSearch = state.isChatSearchActive;

    if (showSearch) {
        chatSearchBarContainer.classList.remove('hidden');
        if (chatSearchInput) {
            chatSearchInput.focus();
        }
        if (savedChatsList) savedChatsList.classList.add('hidden');
        if (chatSearchResultsContainer) chatSearchResultsContainer.classList.remove('hidden');
    } else {
        chatSearchBarContainer.classList.add('hidden');
        if (chatSearchInput && document.activeElement === chatSearchInput) {
            chatSearchInput.blur();
        }
        if (savedChatsList) savedChatsList.classList.remove('hidden');
        if (chatSearchResultsContainer) chatSearchResultsContainer.classList.add('hidden');
    }
}


/**
 * Renders the chat search results or appropriate messages in the chatSearchResultsContainer element.
 */
export function renderChatSearchResults() {
    const { chatSearchResultsContainer, savedChatsList } = elements;
    console.log(`[UI RENDER DEBUG] renderChatSearchResults called. isChatSearchActive: ${state.isChatSearchActive}, Query: "${state.chatSearchQuery}", Results length: ${state.chatSearchResults.length}`);

    if (!chatSearchResultsContainer) {
        console.error("[UI RENDER DEBUG] chatSearchResultsContainer element not found.");
        return;
    }

    chatSearchResultsContainer.innerHTML = ''; 

    if (!state.isChatSearchActive) {
        console.warn("[UI RENDER DEBUG] renderChatSearchResults called but chat search is not active. Hiding results container.");
        chatSearchResultsContainer.classList.add('hidden');
        if (savedChatsList) savedChatsList.classList.remove('hidden');
        return;
    }
    
    chatSearchResultsContainer.classList.remove('hidden');
    if (savedChatsList) savedChatsList.classList.add('hidden');

    const results = state.chatSearchResults;
    const query = state.chatSearchQuery;

    if (query && results.length === 0) {
        chatSearchResultsContainer.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No messages found for "${escapeHtml(query)}".</p>`;
    } else if (results.length > 0) {
        results.forEach(result => {
            const item = document.createElement('div');
            item.classList.add('list-item', 'chat-search-result-item'); // Use classes from style.css
            item.dataset.chatId = result.chat_id;
            item.dataset.messageId = result.id; 

            const chatNameDiv = document.createElement('div');
            chatNameDiv.classList.add('font-semibold'); // Style from style.css
            chatNameDiv.textContent = result.chat_name || `Chat ${result.chat_id}`;
            chatNameDiv.title = result.chat_name || `Chat ${result.chat_id}`;

            const snippetDiv = document.createElement('div');
            snippetDiv.classList.add('text-xs', 'line-clamp-2'); // Style from style.css
            snippetDiv.innerHTML = result.snippet || 'No snippet available.'; 

            const timestampDiv = document.createElement('div');
            timestampDiv.classList.add('text-xs', 'opacity-75'); // Style from style.css
            try {
                timestampDiv.textContent = new Date(result.timestamp).toLocaleString();
            } catch (e) {
                timestampDiv.textContent = 'Invalid Date';
            }

            item.appendChild(chatNameDiv);
            item.appendChild(snippetDiv);
            item.appendChild(timestampDiv);

            item.addEventListener('click', async () => {
                const chatId = parseInt(item.dataset.chatId);
                const messageId = parseInt(item.dataset.messageId);
                
                console.log(`[UI DEBUG] Chat search result clicked. ChatID: ${chatId}, MessageID: ${messageId}`);

                const apiModule = await import('./api.js');
                
                state.setIsLoading(true, "Loading chat...");
                state.setTargetMessageIdToScroll(messageId); 
                state.setIsChatSearchActive(false); 

                try {
                    await apiModule.loadChat(chatId); 
                } catch (error) {
                    console.error(`Error loading chat ${chatId} from search result:`, error);
                    state.setStatusMessage(`Error loading chat: ${error.message}`, true);
                    state.setTargetMessageIdToScroll(null); 
                } finally {
                    state.setIsLoading(false);
                }
            });
            chatSearchResultsContainer.appendChild(item);
        });
    } else if (query) {
        chatSearchResultsContainer.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No messages found.</p>`;
    } else {
        chatSearchResultsContainer.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">Type to search messages...</p>`;
    }
}

/**
 * Renders the note search results or appropriate messages in the savedNotesList element.
 */
export function renderNoteSearchResults() {
    const { savedNotesList } = elements;
    console.log(`[UI RENDER DEBUG] renderNoteSearchResults called. isNoteSearchActive: ${state.isNoteSearchActive}, Query: "${state.noteSearchQuery}", Results length: ${state.noteSearchResults.length}`);

    if (!savedNotesList) {
        console.error("[UI RENDER DEBUG] savedNotesList element not found for rendering search results.");
        return;
    }

    console.log("[UI RENDER DEBUG] Clearing savedNotesList.innerHTML");
    savedNotesList.innerHTML = ''; 

    if (!state.isNoteSearchActive) {
        console.warn("[UI RENDER DEBUG] renderNoteSearchResults called but search is not active. Aborting render and calling renderSavedNotes.");
        renderSavedNotes(); 
        return;
    }

    const results = state.noteSearchResults;
    const query = state.noteSearchQuery;
    console.log(`[UI RENDER DEBUG] Processing query: "${query}", Results:`, JSON.parse(JSON.stringify(results)));

    if (query && results.length === 0) {
        console.log(`[UI RENDER DEBUG] No results found for "${query}".`);
        savedNotesList.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No results found for "${escapeHtml(query)}".</p>`;
    } else if (results.length > 0) {
        console.log(`[UI RENDER DEBUG] Rendering ${results.length} results.`);
        results.forEach((note, index) => {
            const item = document.createElement('div');
            item.classList.add('note-search-result-item'); 
            item.dataset.noteId = note.id;

            const nameDiv = document.createElement('div');
            nameDiv.classList.add('name');
            nameDiv.textContent = note.name || `Note ${note.id}`;
            nameDiv.title = note.name || `Note ${note.id}`;

            const dateDiv = document.createElement('div');
            dateDiv.classList.add('date');
            try {
                const date = new Date(note.last_saved_at);
                const now = new Date();
                const yesterday = new Date(now);
                yesterday.setDate(now.getDate() - 1);
                if (date.toDateString() === now.toDateString()) {
                    dateDiv.textContent = `Today, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
                } else if (date.toDateString() === yesterday.toDateString()) {
                    dateDiv.textContent = `Yesterday, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
                } else {
                    dateDiv.textContent = date.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' });
                }
            } catch (e) {
                dateDiv.textContent = 'Invalid Date';
            }
            
            const snippetDiv = document.createElement('div');
            snippetDiv.classList.add('snippet');
            snippetDiv.innerHTML = note.snippet || 'No snippet available.'; 

            item.appendChild(nameDiv);
            item.appendChild(dateDiv);
            item.appendChild(snippetDiv);
            savedNotesList.appendChild(item);
            console.log(`[UI RENDER DEBUG] Appended result item ${index}: ${note.name}`);
        });
    } else if (query) {
        console.log(`[UI RENDER DEBUG] Query exists but no results (fallback). Query: "${query}"`);
        savedNotesList.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">No results found.</p>`;
    } else {
        console.log(`[UI RENDER DEBUG] No query, search active. Displaying "Type to search...".`);
        savedNotesList.innerHTML = `<p class="text-rz-sidebar-text opacity-75 text-xs p-1">Type to search notes...</p>`;
    }
    console.log(`[UI RENDER DEBUG] Finished renderNoteSearchResults. savedNotesList.childElementCount: ${savedNotesList.childElementCount}`);
}

// ---------------------------------

/**
 * Updates the visual style of a TODO form dropdown based on its selected value.
 * @param {HTMLSelectElement} selectElement - The select element to style.
 */
export function updateTodoDropdownStyles(selectElement) {
    if (!selectElement) return;

    const currentValue = selectElement.value.toLowerCase();
    const selectId = selectElement.id;

    // Define base classes to remove (adjust if your base 'input-field' has more complex styling)
    const classesToRemove = [
        'border-gray-300', 'dark:border-gray-600', // Default border
        'bg-gray-50', 'dark:bg-gray-700',         // Default background
        'text-gray-900', 'dark:text-white',       // Default text
        // Priority classes
        'border-red-500', 'bg-red-50', 'text-red-700', 'dark:border-red-400', 'dark:bg-red-900/50', 'dark:text-red-300',
        'border-yellow-500', 'bg-yellow-50', 'text-yellow-700', 'dark:border-yellow-400', 'dark:bg-yellow-900/50', 'dark:text-yellow-300',
        'border-blue-500', 'bg-blue-50', 'text-blue-700', 'dark:border-blue-400', 'dark:bg-blue-900/50', 'dark:text-blue-300',
        'border-gray-500', 'bg-gray-100', 'text-gray-800', 'dark:border-gray-500', 'dark:bg-gray-700', 'dark:text-gray-300', // For backlog/default priority
        // Status classes
        'border-green-500', 'bg-green-50', 'text-green-700', 'dark:border-green-400', 'dark:bg-green-900/50', 'dark:text-green-300', // Complete
        'border-indigo-500', 'bg-indigo-50', 'text-indigo-700', 'dark:border-indigo-400', 'dark:bg-indigo-900/50', 'dark:text-indigo-300', // In Progress
        'border-pink-500', 'bg-pink-50', 'text-pink-700', 'dark:border-pink-400', 'dark:bg-pink-900/50', 'dark:text-pink-300', // Blocked
        'border-orange-500', 'bg-orange-50', 'text-orange-700', 'dark:border-orange-400', 'dark:bg-orange-900/50', 'dark:text-orange-300', // Paused (using orange as example)
        // Category classes (example, can be expanded)
        'border-purple-500', 'bg-purple-50', 'text-purple-700', 'dark:border-purple-400', 'dark:bg-purple-900/50', 'dark:text-purple-300'
    ];
    selectElement.classList.remove(...classesToRemove);
    // Ensure base input-field class remains if it's separate and provides other essential styles
    selectElement.classList.add('input-field'); // Re-add if it was removed by spread

    let newClasses = ['border-gray-300', 'dark:border-gray-600']; // Default border

    if (selectId === 'todo-priority') {
        if (currentValue === 'high') newClasses = ['border-red-500', 'bg-red-50', 'text-red-700', 'dark:border-red-400', 'dark:bg-red-900/50', 'dark:text-red-300'];
        else if (currentValue === 'medium') newClasses = ['border-yellow-500', 'bg-yellow-50', 'text-yellow-700', 'dark:border-yellow-400', 'dark:bg-yellow-900/50', 'dark:text-yellow-300'];
        else if (currentValue === 'low') newClasses = ['border-blue-500', 'bg-blue-50', 'text-blue-700', 'dark:border-blue-400', 'dark:bg-blue-900/50', 'dark:text-blue-300'];
        else if (currentValue === 'backlog') newClasses = ['border-gray-500', 'bg-gray-100', 'text-gray-800', 'dark:border-gray-500', 'dark:bg-gray-700', 'dark:text-gray-300'];
    } else if (selectId === 'todo-status') {
        if (currentValue === 'complete') newClasses = ['border-green-500', 'bg-green-50', 'text-green-700', 'dark:border-green-400', 'dark:bg-green-900/50', 'dark:text-green-300'];
        else if (currentValue === 'in progress') newClasses = ['border-indigo-500', 'bg-indigo-50', 'text-indigo-700', 'dark:border-indigo-400', 'dark:bg-indigo-900/50', 'dark:text-indigo-300'];
        else if (currentValue === 'blocked') newClasses = ['border-pink-500', 'bg-pink-50', 'text-pink-700', 'dark:border-pink-400', 'dark:bg-pink-900/50', 'dark:text-pink-300'];
        else if (currentValue === 'paused') newClasses = ['border-orange-500', 'bg-orange-50', 'text-orange-700', 'dark:border-orange-400', 'dark:bg-orange-900/50', 'dark:text-orange-300'];
        // 'not started' will use default border/bg
    } else if (selectId === 'todo-category') {
        // Example: Style 'Security' category differently
        if (currentValue === 'security') newClasses = ['border-purple-500', 'bg-purple-50', 'text-purple-700', 'dark:border-purple-400', 'dark:bg-purple-900/50', 'dark:text-purple-300'];
        // Add more category styles as needed
    }
    selectElement.classList.add(...newClasses);
}

// --- TODO List UI Functions ---

/**
 * Populates a select dropdown with options.
 * @param {HTMLSelectElement} selectElement - The select DOM element.
 * @param {string[]} options - An array of string values for the options.
 * @param {string} [defaultValue] - The value to select by default.
 */
function populateTodoDropdownWithOptions(selectElement, options, defaultValue) {
    if (!selectElement) return;
    selectElement.innerHTML = ''; // Clear existing options

    // Add a "Select..." or placeholder option if no default is provided or if it's a generic list
    if (!defaultValue && selectElement.id === 'todo-category') { // Example for category
        const placeholder = document.createElement('option');
        placeholder.value = "";
        placeholder.textContent = `Select ${selectElement.id.replace('todo-', '')}...`;
        placeholder.disabled = true; // Make it non-selectable if it's just a placeholder
        placeholder.selected = true; // Select it by default
        selectElement.appendChild(placeholder);
    }


    options.forEach(optionValue => {
        const option = document.createElement('option');
        option.value = optionValue;
        // Capitalize first letter for display, handle multi-word like "in progress"
        option.textContent = optionValue.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        if (optionValue === defaultValue) {
            option.selected = true;
        }
        selectElement.appendChild(option);
    });
    updateTodoDropdownStyles(selectElement); // Apply styling after populating
}


/**
 * Clears the TODO form fields and resets the hidden ID input.
 */
export function resetTodoForm() {
    if (!elements.todoForm) return;
    elements.todoForm.reset(); // Resets form to default values
    if (elements.todoIdInput) elements.todoIdInput.value = ''; // Clear hidden ID
    if (elements.todoFormSaveButton) elements.todoFormSaveButton.textContent = 'Save Task';
    if (elements.todoModalTitle) elements.todoModalTitle.textContent = 'Add New Task'; // Set title for new task
    state.setCurrentTodoItem(null); // Clear current editing item from state

    // Explicitly enable form elements
    const formElements = elements.todoForm.elements;
    for (let i = 0; i < formElements.length; i++) {
        formElements[i].disabled = false;
    }

    // Populate dropdowns
    populateTodoDropdownWithOptions(elements.todoStatusInput, state.todoStatusOptions, 'pending'); // Default to 'pending' or first option
    populateTodoDropdownWithOptions(elements.todoPriorityInput, state.todoPriorityOptions, 'medium'); // Default to 'medium' or first option
    // For category, assuming it might remain a text input or be populated differently.
    // If category also becomes a select from backend, add:
    // populateTodoDropdownWithOptions(elements.todoCategoryInput, state.todoCategoryOptions, '');

    // Reset dropdown styles (already called by populateTodoDropdownWithOptions)
    // if (elements.todoCategoryInput) updateTodoDropdownStyles(elements.todoCategoryInput);
    // if (elements.todoPriorityInput) updateTodoDropdownStyles(elements.todoPriorityInput);
    // if (elements.todoStatusInput) updateTodoDropdownStyles(elements.todoStatusInput);
}

/**
 * Populates the TODO form with data from a given TODO item for editing.
 * @param {object} todoItem - The TODO item data.
 */
export function populateTodoForm(todoItem) {
    if (!elements.todoForm || !todoItem) {
        resetTodoForm(); // If no item, ensure form is clear
        return;
    }
    if (elements.todoIdInput) elements.todoIdInput.value = todoItem.id;
    if (elements.todoNameInput) elements.todoNameInput.value = todoItem.name;
    if (elements.todoDetailsInput) elements.todoDetailsInput.value = todoItem.details || '';
    if (elements.todoCategoryInput) elements.todoCategoryInput.value = todoItem.category || '';
    if (elements.todoPriorityInput) elements.todoPriorityInput.value = todoItem.priority;
    if (elements.todoStatusInput) elements.todoStatusInput.value = todoItem.status;
    if (elements.todoDueDateInput) {
        // Ensure due_date is in YYYY-MM-DD format for the input[type="date"]
        elements.todoDueDateInput.value = todoItem.due_date ? todoItem.due_date.split('T')[0] : '';
    }
    if (elements.todoFormSaveButton) elements.todoFormSaveButton.textContent = 'Update Task'; // Updated text
    if (elements.todoModalTitle) elements.todoModalTitle.textContent = 'Edit Task'; // Set modal title for editing
    
    showModal(elements.todoModal); // Show the modal with the populated form

    // Focus after modal is shown, slight delay might be needed if modal transition is slow
    setTimeout(() => {
        elements.todoNameInput?.focus();
        // Scrolling into view might not be necessary if modal centers form
    }, 50); // Small delay to ensure modal is visible before focus

    // Populate dropdowns and set values
    populateTodoDropdownWithOptions(elements.todoStatusInput, state.todoStatusOptions, todoItem.status);
    populateTodoDropdownWithOptions(elements.todoPriorityInput, state.todoPriorityOptions, todoItem.priority);
    // if (elements.todoCategoryInput && state.todoCategoryOptions) { // If category becomes dynamic
    //     populateTodoDropdownWithOptions(elements.todoCategoryInput, state.todoCategoryOptions, todoItem.category || '');
    // } else if (elements.todoCategoryInput) { // If category is still a text input
    //     elements.todoCategoryInput.value = todoItem.category || '';
    // }

    // Apply styles to dropdowns (already called by populateTodoDropdownWithOptions)
    // if (elements.todoCategoryInput) updateTodoDropdownStyles(elements.todoCategoryInput);
    // if (elements.todoPriorityInput) updateTodoDropdownStyles(elements.todoPriorityInput);
    // if (elements.todoStatusInput) updateTodoDropdownStyles(elements.todoStatusInput);
}


/**
 * Renders the list of TODO items from the state into the todoListContainer.
 */
export function renderTodoList() {
    if (!elements.todoListContainer) {
        console.error("TODO list container element not found.");
        return;
    }

    const placeholder = document.getElementById('todo-list-placeholder');

    if (state.isLoadingTodos) {
        if (placeholder) placeholder.textContent = 'Loading TODO items...';
        if (todoListJS) todoListJS.clear();
        return;
    }

    const todos = state.todoItems;

    if (!todos || todos.length === 0) {
        if (placeholder) placeholder.textContent = 'No TODO items yet. Add one above!';
        if (todoListJS) todoListJS.clear();
        return;
    }

    if (placeholder) placeholder.textContent = ''; // Clear placeholder if there are items

    if (!todoListJS) {
        initializeTodoListJS();
    }

    if (!todoListJS) {
        console.error("List.js instance for TODOs is not initialized.");
        // Fallback to manual rendering if List.js fails (optional, or just error out)
        elements.todoListContainer.querySelector('.list').innerHTML = '<p class="text-red-500">Error: TODO list UI component failed to load.</p>';
        return;
    }

    todoListJS.clear(); // Clear existing items from List.js

    const prioritySortValues = { low: 1, medium: 2, high: 3 }; // For 'asc' sort by priority

    todos.forEach(todo => {
        // Data for List.js item
        const itemData = {
            id: todo.id, // Keep id for data attributes
            name: todo.name,
            details: todo.details || '',
            category: todo.category || '',
            priorityDisplay: `P: ${todo.priority.charAt(0).toUpperCase() + todo.priority.slice(1)}`,
            prioritySort: prioritySortValues[todo.priority.toLowerCase()] || 0,
            statusDisplay: todo.status.charAt(0).toUpperCase() + todo.status.slice(1).replace('-', ' '),
            statusSort: todo.status, // List.js will sort this alphabetically by default
            dueDateDisplay: todo.due_date ? new Date(todo.due_date + 'T00:00:00').toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }) : '',
            dueDateSort: todo.due_date ? todo.due_date.replace(/-/g, '') : '99999999', // YYYYMMDD for sorting, future for nulls
        };

        // Add data to List.js. It will use the 'item' template defined in options.
        const addedItems = todoListJS.add(itemData);
        if (addedItems && addedItems.length > 0) {
            const listItemElement = addedItems[0].elm; // Get the DOM element List.js created
            listItemElement.dataset.todoId = todo.id; // Ensure the main ID is on the item

            // Apply dynamic classes (like background color)
            listItemElement.className = `todo-item p-5 mb-4 rounded-xl shadow-lg border flex flex-col md:flex-row md:items-start gap-4 transition-all duration-150 ease-in-out ${getTodoItemBgColor(todo.status, todo.due_date)}`;

            // Attach event listeners for edit/delete buttons
            const editButton = listItemElement.querySelector('.edit-btn');
            if (editButton) {
                editButton.addEventListener('click', () => {
                    state.setCurrentTodoItem(todos.find(t => t.id === todo.id));
                });
            }
            const deleteButton = listItemElement.querySelector('.delete-btn');
            if (deleteButton) {
                deleteButton.addEventListener('click', async () => {
                    await api.deleteTodoItem(todo.id);
                });
            }
        }
    });

    // After adding all items, if a sort key is active, apply it.
    // This ensures the list is sorted according to the current criteria after initial render or data update.
    if (state.todoSortKey !== 'default' && todoListJS) {
        todoListJS.sort(state.todoSortKey, { order: state.todoSortDirection });
    } else if (todoListJS) {
        // Apply default sort if no specific key is set (List.js doesn't have a multi-level default sort like JS .sort())
        // For now, List.js will keep the order items were added, or its own default if any.
        // To achieve the complex default sort, we'd need to pre-sort `todos` array before adding to List.js,
        // or implement a custom sort function for List.js.
        // For simplicity, we'll rely on List.js's single-key sort for now.
        // The initial order will be as received from the backend or after the JS default sort if we re-add it before List.js.
        // Let's re-add the default JS sort before giving data to List.js for the 'default' case.
        const defaultPriorityOrder = { high: 1, medium: 2, low: 3, default: 4 };
        const defaultStatusOrder = { pending: 1, 'in-progress': 2, completed: 3, default: 4 };
        const preSortedTodos = [...state.todoItems].sort((a, b) => {
            const statusA = defaultStatusOrder[a.status] || defaultStatusOrder.default;
            const statusB = defaultStatusOrder[b.status] || defaultStatusOrder.default;
            if (statusA !== statusB) return statusA - statusB;
            const dateA = a.due_date ? new Date(a.due_date + 'T00:00:00') : null;
            const dateB = b.due_date ? new Date(b.due_date + 'T00:00:00') : null;
            if (dateA && dateB) {
                if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
            } else if (dateA) return -1;
            else if (dateB) return 1;
            const priorityA = defaultPriorityOrder[a.priority] || defaultPriorityOrder.default;
            const priorityB = defaultPriorityOrder[b.priority] || defaultPriorityOrder.default;
            return priorityA - priorityB;
        });
        
        // Re-populate List.js with pre-sorted items for the default case
        todoListJS.clear();
        preSortedTodos.forEach(todo => {
            const itemData = { /* ... as above ... */ 
                id: todo.id, name: todo.name, details: todo.details || '', category: todo.category || '',
                priorityDisplay: `P: ${todo.priority.charAt(0).toUpperCase() + todo.priority.slice(1)}`,
                prioritySort: prioritySortValues[todo.priority.toLowerCase()] || 0,
                statusDisplay: todo.status.charAt(0).toUpperCase() + todo.status.slice(1).replace('-', ' '),
                statusSort: todo.status,
                dueDateDisplay: todo.due_date ? new Date(todo.due_date + 'T00:00:00').toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }) : '',
                dueDateSort: todo.due_date ? todo.due_date.replace(/-/g, '') : '99999999',
            };
            const addedItems = todoListJS.add(itemData);
            if (addedItems && addedItems.length > 0) {
                const listItemElement = addedItems[0].elm;
                listItemElement.dataset.todoId = todo.id;
                listItemElement.className = `todo-item p-5 mb-4 rounded-xl shadow-lg border flex flex-col md:flex-row md:items-start gap-4 transition-all duration-150 ease-in-out ${getTodoItemBgColor(todo.status, todo.due_date)}`;
                const editButton = listItemElement.querySelector('.edit-btn');
                if (editButton) editButton.addEventListener('click', () => { state.setCurrentTodoItem(todos.find(t => t.id === todo.id)); });
                const deleteButton = listItemElement.querySelector('.delete-btn');
                if (deleteButton) deleteButton.addEventListener('click', async () => { await api.deleteTodoItem(todo.id); });
            }
        });
    }
}


// Helper function to create a TODO item DOM element (will be used by List.js item template)
// This function is now effectively replaced by the List.js item template.
// The styling and button logic will be applied after List.js creates the item.
/*
    sortedTodos.forEach(todo => {
        const itemEl = document.createElement('div');
        itemEl.className = `todo-item p-5 mb-4 rounded-xl shadow-lg border flex flex-col md:flex-row md:items-start gap-4 transition-all duration-150 ease-in-out ${getTodoItemBgColor(todo.status, todo.due_date)}`;
        itemEl.dataset.todoId = todo.id;

        // Main content block (Name, Details, Category)
        const mainContent = document.createElement('div');
        mainContent.className = 'flex-grow min-w-0'; // Added min-w-0 for flexbox truncation

        const nameEl = document.createElement('h4');
        nameEl.className = `text-xl font-semibold break-words ${todo.status === 'completed' ? 'line-through text-gray-500 dark:text-gray-400' : 'text-[--rz-text-primary]'}`;
        nameEl.textContent = todo.name;
        mainContent.appendChild(nameEl);

        if (todo.details) {
            const detailsEl = document.createElement('p');
            detailsEl.className = `text-sm mt-2 break-words ${todo.status === 'completed' ? 'text-gray-400 dark:text-gray-500' : 'text-[--rz-text-secondary]'}`;
            // Simple whitespace preservation for newlines in details
            detailsEl.style.whiteSpace = 'pre-wrap';
            detailsEl.textContent = todo.details;
            mainContent.appendChild(detailsEl);
        }
        if (todo.category) {
            const categoryEl = document.createElement('p');
            categoryEl.className = `text-xs mt-3 inline-block px-3 py-1 rounded-full font-medium bg-gray-200 text-gray-700 dark:bg-gray-700 dark:text-gray-200`;
            categoryEl.textContent = todo.category;
            mainContent.appendChild(categoryEl);
        }
        
        itemEl.appendChild(mainContent);

        // Info block (Priority, Status, Due Date) - Aligned to the right on larger screens
        const infoBlock = document.createElement('div');
        infoBlock.className = 'flex flex-col md:items-end md:text-right space-y-2 md:space-y-1 md:w-52 flex-shrink-0 mt-4 md:mt-0'; // Adjusted width and spacing

        const priorityEl = document.createElement('span');
        priorityEl.className = `text-xs font-semibold px-3 py-1 rounded-full ${getPriorityBadgeColor(todo.priority)}`;
        priorityEl.textContent = `P: ${todo.priority.charAt(0).toUpperCase() + todo.priority.slice(1)}`;
        infoBlock.appendChild(priorityEl);
        
        const statusEl = document.createElement('span');
        statusEl.className = `text-xs font-semibold px-3 py-1 rounded-full ${getStatusBadgeColor(todo.status)}`;
        statusEl.textContent = todo.status.charAt(0).toUpperCase() + todo.status.slice(1).replace('-', ' ');
        infoBlock.appendChild(statusEl);

        if (todo.due_date) {
            const dueDateEl = document.createElement('p');
            const dueDate = new Date(todo.due_date + 'T00:00:00'); // Ensure date is parsed as local
            dueDateEl.className = `text-sm font-medium ${getDueDateColor(todo.due_date, todo.status)}`;
            dueDateEl.textContent = `Due: ${dueDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' })}`;
            infoBlock.appendChild(dueDateEl);
        }
        
        itemEl.appendChild(infoBlock);

        // Actions block (Edit, Delete) - Always at the end
        const actionsEl = document.createElement('div');
        actionsEl.className = 'flex items-center space-x-3 mt-4 md:mt-0 md:ml-6 flex-shrink-0';

        const editButton = document.createElement('button');
        editButton.className = 'btn btn-icon btn-sm text-[--rz-text-secondary] hover:text-[--rz-accent-default] p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700';
        editButton.innerHTML = '<i class="fas fa-edit fa-fw"></i>'; // Added fa-fw for fixed width
        editButton.title = "Edit TODO";
        editButton.addEventListener('click', () => {
            state.setCurrentTodoItem(todo); 
        });

        const deleteButton = document.createElement('button');
        deleteButton.className = 'btn btn-icon btn-sm text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-50 dark:hover:bg-red-900/50';
        deleteButton.innerHTML = '<i class="fas fa-trash-alt fa-fw"></i>'; // Added fa-fw
        deleteButton.title = "Delete TODO";
        deleteButton.addEventListener('click', async () => {
            await api.deleteTodoItem(todo.id);
        });
        
        actionsEl.appendChild(editButton);
        actionsEl.appendChild(deleteButton);
        itemEl.appendChild(actionsEl);

        // elements.todoListContainer.appendChild(itemEl); // List.js appends to its .list container
    // }); // End of forEach for sortedTodos
// } // End of renderTodoList

// --- List.js instance and options ---
let todoListJS = null;
const todoListOptions = {
    valueNames: [
        'name', 'details', 'category', // Direct text content
        { name: 'prioritySort', attr: 'data-priority-sortval' }, // Sort by this hidden value
        'priorityDisplay', // Visible priority text
        { name: 'dueDateSort', attr: 'data-duedate-sortval' },   // Sort by this hidden value
        'dueDateDisplay',   // Visible due date text
        'statusSort',       // Sort by status text
        'statusDisplay'     // Visible status text
    ],
    // Define the HTML structure for each item List.js will create/manage
    // List.js will populate elements with class names matching valueNames.
    // We will add data attributes and buttons dynamically after List.js adds the item.
    item: `
        <li> <!-- List.js uses <li> by default if parent is <ul>, or <div> if parent is <div>. Let's use <li> and ensure .list is a <ul> or List.js will make divs. -->
            <!-- The main todo-item class and dynamic background will be set after List.js creates the element -->
            <div class="main-content">
                <h4 class="name"></h4>
                <p class="details" style="white-space: pre-wrap;"></p>
                <p><span class="category-display category"></span></p> <!-- category-display for text, category for sort -->
            </div>
            <div class="info-block">
                <span class="priority-display" data-priority-sortval></span>
                <span class="status-display statusSort"></span> <!-- statusSort for sort -->
                <p class="due-date-display" data-duedate-sortval></p>
            </div>
            <div class="actions">
                <button class="btn btn-icon btn-sm text-[--rz-text-secondary] hover:text-[--rz-accent-default] p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 edit-btn" title="Edit TODO"><i class="fas fa-edit fa-fw"></i></button>
                <button class="btn btn-icon btn-sm text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-50 dark:hover:bg-red-900/50 delete-btn" title="Delete TODO"><i class="fas fa-trash-alt fa-fw"></i></button>
            </div>
        </li>
    `
};

function initializeTodoListJS() {
    if (elements.todoListContainer && !todoListJS) {
        // Ensure the .list element exists for List.js
        let listElement = elements.todoListContainer.querySelector('.list');
        if (!listElement) {
            console.error("'.list' element not found inside #todo-list-container for List.js initialization.");
            return;
        }
        // If listElement is not a UL, List.js items will be DIVs.
        // If we want LIs, ensure listElement is a UL. For now, assuming it's a div and List.js makes child divs.
        // The item template uses <li>, so List.js will create <li>s if the list parent is a <ul>.
        // If .list is a div, it will create divs based on the item template's outer tag.
        // Let's ensure our item template starts with <li> and List.js will handle it.

        try {
            todoListJS = new List(elements.todoListContainer, todoListOptions);
            console.log("List.js initialized for TODOs.");
        } catch (e) {
            console.error("Error initializing List.js for TODOs:", e);
            todoListJS = null; // Ensure it's null if init fails
        }
    }
}


function getTodoItemBgColor(status, dueDateStr) {
    if (status === 'completed') {
        return 'bg-green-50 border-green-300 dark:bg-green-900/50 dark:border-green-700 opacity-70 hover:opacity-100';
    }
    if (dueDateStr) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const dueDate = new Date(dueDateStr + 'T00:00:00'); 

        if (dueDate < today) {
            return 'bg-red-50 border-red-300 dark:bg-red-900/50 dark:border-red-700 hover:shadow-red-200/50'; 
        } else if (dueDate.getTime() === today.getTime()) {
            return 'bg-yellow-50 border-yellow-300 dark:bg-yellow-900/50 dark:border-yellow-700 hover:shadow-yellow-200/50'; 
        }
    }
    return 'bg-white border-[--rz-border-light] dark:bg-gray-800 dark:border-gray-700 hover:shadow-indigo-100/50'; 
}

function getPriorityBadgeColor(priority) {
    switch (priority) {
        case 'high': return 'bg-red-100 text-red-800 dark:bg-red-700 dark:text-red-100 border border-red-300 dark:border-red-600';
        case 'medium': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-700 dark:text-yellow-100 border border-yellow-300 dark:border-yellow-600';
        case 'low': return 'bg-blue-100 text-blue-800 dark:bg-blue-700 dark:text-blue-100 border border-blue-300 dark:border-blue-600';
        default: return 'bg-gray-100 text-gray-800 dark:bg-gray-600 dark:text-gray-100 border border-gray-300 dark:border-gray-500';
    }
}

function getStatusBadgeColor(status) {
     switch (status) {
        case 'pending': return 'bg-orange-100 text-orange-800 dark:bg-orange-700 dark:text-orange-100 border border-orange-300 dark:border-orange-600';
        case 'in-progress': return 'bg-indigo-100 text-indigo-800 dark:bg-indigo-700 dark:text-indigo-100 border border-indigo-300 dark:border-indigo-600';
        case 'completed': return 'bg-green-100 text-green-800 dark:bg-green-700 dark:text-green-100 border border-green-300 dark:border-green-600';
        default: return 'bg-gray-100 text-gray-800 dark:bg-gray-600 dark:text-gray-100 border border-gray-300 dark:border-gray-500';
    }
}

function getDueDateColor(dueDateStr, status) {
    if (status === 'completed') {
        return 'text-gray-500 dark:text-gray-400';
    }
    if (dueDateStr) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const dueDate = new Date(dueDateStr + 'T00:00:00');

        if (dueDate < today) return 'text-red-600 dark:text-red-400 font-bold'; 
        if (dueDate.getTime() === today.getTime()) return 'text-yellow-600 dark:text-yellow-400 font-bold'; 
    }
    return 'text-[--rz-text-muted] dark:text-gray-400'; 
}


// --- TODO State Change Handlers ---
export function handleStateChange_todoItems() {
    renderTodoList();
}

export function handleStateChange_currentTodoItem() {
    populateTodoForm(state.currentTodoItem);
}

export function handleStateChange_isLoadingTodos() {
    if (state.isLoadingTodos && elements.todoListContainer) {
        elements.todoListContainer.innerHTML = '<p class="text-[--rz-text-muted] text-center py-4">Loading TODO items...</p>';
    }
    // Disable form elements if loading TODOs or globally loading
    const formShouldBeDisabled = state.isLoadingTodos || state.isLoading;
    if (elements.todoForm) {
        const formElements = elements.todoForm.elements;
        for (let i = 0; i < formElements.length; i++) {
            formElements[i].disabled = formShouldBeDisabled;
        }
    }
}

export function handleStateChange_todoStatusOptions() {
    // This might be called if options are dynamically updated later.
    // For now, it ensures dropdowns are populated if state changes after initial load.
    if (elements.todoForm && (state.currentTodoItem === null || elements.todoIdInput?.value === '')) { // Only re-populate for new task form
        populateTodoDropdownWithOptions(elements.todoStatusInput, state.todoStatusOptions, 'pending');
    } else if (elements.todoForm && state.currentTodoItem) { // For edit form, re-populate with current value
        populateTodoDropdownWithOptions(elements.todoStatusInput, state.todoStatusOptions, state.currentTodoItem.status);
    }
}

export function handleStateChange_todoPriorityOptions() {
    if (elements.todoForm && (state.currentTodoItem === null || elements.todoIdInput?.value === '')) {
        populateTodoDropdownWithOptions(elements.todoPriorityInput, state.todoPriorityOptions, 'medium');
    } else if (elements.todoForm && state.currentTodoItem) {
        populateTodoDropdownWithOptions(elements.todoPriorityInput, state.todoPriorityOptions, state.currentTodoItem.priority);
    }
}

// --- End TODO List UI Functions ---
